# #Fonctions user-friendly tableaux croises---------------------------------------
#
#
# #Fonction tab : tableau croise pondere compatible tidyverse
# # Ajouter  : - plusieurs tableaux si plusieurs variables sont indiquees (y compris wt) ?
# #            - une fonction tout-en-un pour les etudiants,
# #            une autre decomposee pour les utilisateurs du tidyverse ?
# #            - faire des wrappers (versions : normal ; tout est simplifie ; resultats ?)
# #            - Autres fonctions ? : - soustraire moyenne de la colonne/ligne
# #                                   - intervalles de confiance
# #                                   - passer sup_contrib, etc., à l'extérieur,
# # Ajouter ?
# #            - regles de formatage conditionnel a passer dans tab_xl ?
# #            - choisir signe pourcentages ou pas dans le format
# #            - total supplémentaire avec effectifs non pondéré par ligne ?
# #            - une condition filter en argument pour passer dans tribble (utilisée au dernier moment) ? Et donc une liste pour subtext ?
# # BUGS       - Format de sortie pour les effectifs : double not decimal (ACM output) ?
# #            - Enlever design effect ?
# #            - use stopifnot and switch ----------------------------------------
# #            - make perc faster, compared to counts ----------------------------
# #            - rename variables if "NA", "NULL", "Total", "Ensemble", "no_var", etc.
# #            - Unweighted counts in the title of each graph.
# #            - Error when after cleannames, two levels have the same name ("P6Q_27-OQ-A aliment ♂ PME" / "P6Q_28-OQ-A aliment ♂ PME")
# #            - Totaltab = "no" don’t work anymore.
# #            - Error with empty tabs when calculating Chi2
#
# # Family of functions :
# # tab
# # tab_multi
# # tab_sup
# # tab_ci
# #
# # tab_df
# # tab_draw
# #
# # tab_map_rownames
# # tab_map_columns
# # tab_map_rowwise #?
# #
# # tab_transpose
#
# #' Crosstabs
# #' @description A full-featured function to create, manipulate and print
# #'  crosstabs. It can be decomposed in several functions : data is prepared with
# #'  \code{\link{tab_prepare}} ; calculations are made on a single dataframe
# #'  with \code{\link{tab_df}} ; the result is finally "widened" and split
# #'  in as many tables as necessary with \code{\link{tab_draw}}.
# #'  You can then modify tables with any functions using \code{\link{tab_map}}.
# #' @param data A data frame.
# #' @param var1,var2,var3 \code{var1} is the row variable. \code{var2} is the
# #' column variable. A table is made for each level in \code{var3} :
# #' leave this table variable empty to make a simple crosstab. All variables
# #' will be converted to factor.
# #' @param wt A weight variable, of class numeric. Leave empty for unweighted
# #'  results.
# #' @param show_na Set to \code{FALSE} to exclude individuals with \code{NA} at
# #'  \code{var1}, \code{var2} or \code{var3}.
# #' @param keep_unused_levels Set to \code{TRUE} to keep empty levels of factors.
# #' @param tot \code{"auto"} prints all totals, unless it is a one-variable
# #'  table. \code{"no"} remove them all, \code{"row"} add a total row, \code{"col"}
# #'  a total column, and \code{"all"} and \code{c("row", "col")} stand for both.
# #' @param perc Type of percentages. \code{"no"}, \code{"row"} and \code{"col"}
# #' are self-evident. \code{"all"} print frequencies for each table.
# #' If \code{var3} is provided, \code{"all_tabs"} calculate the proportion
# #' of each value in the total population.
# #' @param totaltab Only useful when \code{var3} is provided. \code{"table"}
# #'  means that a totaltable will be created. \code{"line"} means it will be
# #'  reduced to a single row. \code{"no"}  means it will be totally removed.
# #' @param digits The number of digits to print, as an integer.
# #' @param cleannames Set to \code{TRUE} to clean levels names, by removing
# #' prefix numbers like "1-", and text in parenthesis.
# #' @param subtext A character vector to print legend rows under the
# #' (list of) table(s) in \code{\link{tab_xl}}
# #' @param sort_by A variable to sort rows in each table with. It must be one
# #'  of the principal or supplementary column variables.
# #' @param minimum_headcount The minimum unweighted count in each row/col.
# #'  Any row/col with less count will be printed in grey in \code{\link{tab_xl}}.
# #' @param rare_to_other When set to \code{TRUE}, levels with less count
# #' than minimum_headcount will be merged into an "Other" level.
# #' @param another_total Set to \code{TRUE} to add another total line.
# #' Useful to compare row frequencies with \code{perc = "row"}, or columns
# #' frequencies with \code{perc = "col"}. It only prints when you pass tabs
# #' into \code{\link{tab_xl}}.
# #' @param sup_contrib Add a column and a row with the contribution of all levels
# #'  to the variance of the tabs. It only prints when you pass tabs
# #'  into \code{\link{tab_xl}}.
# #' @param result Any intermediate result in the calculation of Chi2/variance
# #'  can be printed :
# #'   \itemize{
# #'    \item \code{"observed"} : base table with counts or frequencies
# #'    \item \code{"contrib"} : contribution of cells to variance, with signs + or -
# #'     for attractions and repulsions
# #'    \item \code{"expected"} : expected frequencies
# #'    \item \code{"spread"} : spread between observed and expected frequencies
# #'    \item \code{"binding_ratio"} : spread divided by expected frequencies
# #'    \item \code{"ctr_abs"} : absolute contributions of cells to variance
# #'    \item \code{"ctr_no_sign"} : relative contributions of cells to variance
# #'  }
# #' @param force_unique_table If \code{var3} is provided, set to
# #'  \code{TRUE} to print multiple tables into one.
# #' @param accelerate If \code{TRUE} makes the function faster, but produces
# #'  less metadata (Chi2, unweighted counts, contributions of cells to variance).
# #'
# #' @return If \code{var3} is empty, a single table with
# #' class \code{\link{single_tab}}, which is a special
# #'  \code{\link[tibble]{tibble}} with adapted printing method.
# #'  If \code{var3} is provided, a list of single tables, with class
# #'   \code{\link{tab}} (a list of \code{\link[tibble]{tibble}}).
# #'   The variables classes depend on the chosen parameters (\code{\link{pct}},
# #'   \code{double}, \code{character}). You can then add supplementary rows or
# #'   cols with \code{\link{tab_sup}}. You can also modify tables with any
# #'   function using \code{\link{tab_map}} (better not to directly use
# #'    \code{purrr::\link[purrr]{map}}, which removes attributes).
# #' @export
# #'
# #' @examples
# #' tab(forcats::gss_cat, marital, race)
# #'
# #' tab(forcats::gss_cat, marital, race, perc = "row")
# #'
# #' tab(forcats::gss_cat, marital, race, year, perc = "row")
# #'
# #' dplyr::storms %>%
# #'   tab(status, category) %>%
# #'   tab_sup(sup_rows = c("pressure", "wind"), print_sup = TRUE)
# #'
# #' \dontrun{
# #' forcats::gss_cat %>%
# #'   tab(marital, race, perc = "row") %>%
# #'   tab_xl()
# #' }
# #'
# #' # To program several tables with different parameters at the same time :
# #' purrr::pmap(
# #'   tibble::tribble(
# #'     ~var1    , ~var2       ,  ~perc,
# #'     "marital", "race"      ,  "no" ,
# #'     "marital", "race"      ,  "row",
# #'     "marital", "race"      ,  "col",
# #'     "relig"  , "race"      ,  "no" ,
# #'     "relig"  , "race"      ,  "row",
# #'     "relig"  , "race"      ,  "col",
# #'   ),
# #'   .f = tab,
# #'   data = forcats::gss_cat, sort_by = c("White", "desc")) #%>%
# #' #tab_xl(only_one_sheet = TRUE)
# tab <-
#   function(data, var1, var2, var3, wt, show_na = TRUE, keep_unused_levels = FALSE,
#            #sup_cols = NULL, sup_rows = NULL, only_first_level = TRUE, not_last_level = TRUE, drop_sup_na = FALSE,
#            tot = "auto", perc = c("no", "row", "col", "all", "all_tabs"), totaltab = c("table", "line", "no"),
#            digits = 0, cleannames = FALSE, subtext, sort_by = "no",
#            minimum_headcount = 30, rare_to_other = FALSE,
#            another_total = FALSE, sup_contrib = FALSE,
#            result = c("observed", "contrib", "expected", "spread", "binding_ratio", "ctr_abs", "ctr_no_sign"),
#            #confidence_intervals = FALSE, conf_level = 0.95, design_effect = TRUE, #CItype = c("range", "+-"),
#            force_unique_table = FALSE, accelerate = FALSE #, no_formatting = FALSE
#            #multicols = FALSE, multirows = FALSE, print_sup = FALSE,
#            ) { #... tidydots sometwhere ?
#
#
#
#     # if ( is.data.frame(data) | ! is_tab(data)) {
#     #   original_data <- data
#     #   original_tablist <- NULL
#
#     data_name <- substitute(data) %>% as.character() %>% .[length(.)]
#     if (data_name == ".") { #Find original name if data has been piped.
#       data_name <- get_orig_name(data)
#       data_name <- stringr::str_remove(data_name, "^[^\\$]+\\$")
#     }
#     # }
#
#     # if (is_tab(data) | all(purrr::map_lgl(data, ~ is_tab(.)))) {
#     #   # if (force_unique_table == TRUE){
#     #   #   stop("Cannot use tabw with pipe/from tab with force_unique_table == TRUE") }
#     #   original_data <- NULL
#     #   original_tablist <- data
#     #   if (is_tab(data)) {
#     #     original_args <- purrr::pluck(data, purrr::attr_getter("args"))
#     #   } else {
#     #     original_args <- purrr::pluck(data[[1]], purrr::attr_getter("args"))
#     #   }
#     #
#     #   if (missing(wt) & !is.na(original_args$wt) ) wt <-         original_args$wt
#     #   if (missing(perc) )                perc <-                 original_args$perc
#     #   if (missing(show_na) )             show_na <-              original_args$show_na
#     #   if (missing(keep_unused_levels) )  keep_unused_levels <-   original_args$keep_unused_levels
#     #   if (missing(minimum_headcount) )   minimum_headcount <-    original_args$minimum_headcount
#     #   if (missing(tot) )                 tot <-                  original_args$totals
#     #   if (missing(totaltab) )            totaltab <-             original_args$totaltab
#     #   if (missing(digits) )              digits <-               original_args$digits
#     #   if (missing(cleannames) )          cleannames <-           original_args$cleannames
#     #   if (missing(rare_to_other)) rare_to_other <- original_args$rare_to_other
#     #   # if (missing(sup_cols) )            sup_cols <-             original_args$sup_cols
#     #   # if (missing(sup_rows) )            sup_rows <-             original_args$sup_rows
#     #   if (missing(only_first_level) )    only_first_level <-     original_args$only_first_level
#     #   if (missing(drop_sup_na) )         drop_sup_na <-          original_args$drop_sup_na
#     #   if (missing(another_total) )       another_total <-        original_args$another_total
#     #   #if (missing(sup_contrib) )         sup_contrib <-          original_args$sup_contrib
#     #   # if (missing(confidence_intervals)) confidence_intervals <- original_args$confidence_intervals
#     #   if (missing(conf_level) )          conf_level <-           original_args$conf_level
#     #   if (missing(subtext) )             subtext <-              original_args$subtext
#     #
#     #   data <- original_args$original_data
#     #   data_name <- original_args$original_data_name
#     #   # when ".", find all databases, then test names and length ?
#     #   # ls()[purrr::map_lgl(ls(), ~ any(class(get(.)) == "data.frame"))]
#     #   # data <- get(data_name)
#     #    }
#     # if (!("data.frame" %in% class(data)) & ! is_tab(data)) stop("data is of the wrong type")
#
#
#     if (missing(var1) & missing(var2)) stop("var1 or var2 needed")
#
#
#     #"Auto" settings, options incompatibilities and warnings
#     if (tot[1] == "all") tot <- c("row", "col")
#     if (tot[1] == "auto" & missing(var2) == TRUE ) tot <- c("row")
#     if (tot[1] == "auto" & missing(var1) == TRUE ) tot <- c("col")
#     if (tot[1] == "auto" & missing(var1) == FALSE & missing(var2) == FALSE) tot <- c("row", "col")
#
#
#     if ( (missing(var1) == TRUE | missing(var2) == TRUE ) & result[1] != "observed" ) {
#       result <- "observed"
#       warning("since there is no first or second variable, result was set to 'observed")
#     }
#     if (perc[1] != "all" & result[1] %in% c("spread", "binding_ratio", "contrib", "ctr_abs", "ctr_no_sign")) {
#       perc <- "all"
#       warning("since result is not 'observed' or 'expected', percentages were set to 'all")
#     }
#
#     if (missing(subtext) ) subtext <- NA_character_
#
#     if (!missing(sort_by) & (class(sort_by) != "character" | length(sort_by) > 2 |
#                              ifelse(is.na(sort_by[2] != "desc"), FALSE, sort_by[2] != "desc") )
#     ) stop("sort_by must be a character vector of length 1 (or 2 with 'desc')")
#
#
#     if (missing(var1)) {
#       data %<>% dplyr::mutate(no_var1 = factor("n"))
#       var1 <- rlang::expr(no_var1)
#     } else {
#       var1 <- rlang::ensym(var1)
#       if (as.character(var1) %in% c("NA", "NULL", "no")) {
#         data %<>% dplyr::mutate(no_var1 = factor("n"))
#         var1 <- rlang::expr(no_var1)
#       }
#     }
#
#     if (missing(var2)) {
#       data %<>% dplyr::mutate(no_var2 = factor("n"))
#       var2 <- rlang::expr(no_var2)
#     } else {
#       var2 <- rlang::ensym(var2)
#       if (as.character(var2) %in% c("NA", "NULL", "no")) {
#         data %<>% dplyr::mutate(no_var2 = factor("n"))
#         var2 <- rlang::expr(no_var2)
#       }
#     }
#
#     if (missing(var3)) {
#       data %<>% dplyr::mutate(no_var3 = factor(" "))
#       var3 <- rlang::expr(no_var3)
#     } else {
#       var3 <- rlang::ensym(var3)
#       if (as.character(var3) %in% c("NA", "NULL", "no")) {
#         data %<>% dplyr::mutate(no_var3 = factor(" "))
#         var3 <- rlang::expr(no_var3)
#       }
#     }
#
#     if (missing(wt)) {
#       data %<>% dplyr::mutate(no_weight = 1)
#       wt <- rlang::expr(no_weight)
#     } else {
#       wt <- rlang::ensym(wt)
#       if (as.character(wt) %in% c("NA", "NULL", "no")) {
#         data %<>% dplyr::mutate(no_weight = 1)
#         wt <- rlang::expr(no_weight)
#       }
#     }
#
#     #dat <- data %>% dplyr::select(!!var1, !!var2, !!var3, !!wt,
#     #  tidyselect::all_of(sup_cols), tidyselect::all_of(sup_rows))
#
#     if (rlang::quo_name(var1) == "no_var1") {no_var1 <- TRUE} else {no_var1 <- FALSE}
#     if (rlang::quo_name(var2) == "no_var2") {no_var2 <- TRUE} else {no_var2 <- FALSE}
#     if (rlang::quo_name(var3) == "no_var3") {no_var3 <- TRUE} else {no_var3 <- FALSE}
#     if (rlang::quo_name(wt) == "no_weight") {no_weight <- TRUE} else {no_weight <- FALSE}
#
#     data <-
#       tab_prepare(data, !!var1, !!var2, !!var3,
#                        show_na = show_na, cleannames = cleannames,
#                        minimum_headcount = minimum_headcount, rare_to_other = rare_to_other)
#
#
#     if (cleannames == TRUE & sort_by[1] != "no") sort_by %<>%
#       stringr::str_remove(cleannames_condition())
#
#     wtable <-
#       tab_df(data, !!var1, !!var2, !!var3, !!wt, perc,
#                 digits, sort_by = sort_by, accelerate = accelerate) #another_total = another_total,
#
#     #Sortie du tableau et mise en forme --------------------------------------
#
#     #Tests :
#     # tot = "no"            ; totaltab = "no"
#     # tot = "no"            ; totaltab = "line"
#     # tot = "no"            ; totaltab = "table"
#     # tot = "row"           ; totaltab = "no"
#     # tot = "row"           ; totaltab = "line"
#     # tot = "row"           ; totaltab = "table"
#     # tot = "col"           ; totaltab = "no"
#     # tot = "col"           ; totaltab = "line"
#     # tot = "col"           ; totaltab = "table"
#     # tot = c("row", "col") ; totaltab = "no"
#     # tot = c("row", "col") ; totaltab = "line"
#     # tot = c("row", "col") ; totaltab = "table"
#
#     # perc = "no"      ; confidence_intervals = FALSE ; result = "observed"
#     # perc = "row"      ; confidence_intervals = FALSE ; result = "observed"
#     # perc = "col"      ; confidence_intervals = FALSE ; result = "observed"
#     # perc = "all"      ; confidence_intervals = FALSE ; result = "observed"
#     # perc = "all_tabs" ; confidence_intervals = FALSE ; result = "observed"
#
#     # perc = "row"      ; confidence_intervals = TRUE  ; result = "observed"
#     # perc = "col"      ; confidence_intervals = TRUE  ; result = "observed"
#     # perc = "all"      ; confidence_intervals = TRUE  ; result = "observed"
#     # perc = "all_tabs" ; confidence_intervals = TRUE  ; result = "observed"
#     # perc = "no"       ; confidence_intervals = TRUE  ; result = "observed"
#
#     # perc = "row"      ; confidence_intervals = FALSE ; result = "contrib"
#     # perc = "col"      ; confidence_intervals = TRUE  ; result = "contrib"
#     # perc = "all"      ; confidence_intervals = FALSE ; result = "expected"
#     # perc = "all_tabs" ; confidence_intervals = TRUE  ; result = "spread"
#     # perc = "row"      ; confidence_intervals = FALSE ; result = "binding_ratio"
#     # perc = "col"      ; confidence_intervals = TRUE  ; result = "ctr_no_sign"
#     # perc = "col"      ; confidence_intervals = TRUE  ; result = "ctr_abs"
#
#     #Faire le tableau final :
#
#     if (result[1] == "observed") {
#       if (perc[1] == "no")              result_base_var <- rlang::expr(weighted_n)
#       if (perc[1] != "no")              result_base_var <- rlang::expr(pct)
#       #if (confidence_intervals == TRUE) result_base_var <- rlang::expr(resCI)
#     } else { # if (result %in% c("contrib", "expected", "spread", "binding_ratio", "ctr_abs", "ctr_no_sign"))
#       result_base_var <- rlang::enquo(result)
#     }
#
#     #if (multicols == FALSE & multirows == FALSE) {
#
#     tabs <- wtable %>%
#       tab_draw(!!result_base_var, row_var = !!var1, col_var = !!var2, tab_var = !!var3,
#               tot = tot, totaltab = totaltab[1], keep_unused_levels = keep_unused_levels,
#               subtext = subtext)  #col_var_sort = col_var_sort, #perc = perc[1]
#     #}
#
#
#
#
#     # Put Chi2 table in function
#     count_text <- stringi::stri_unescape_unicode("Individus enqu\\u00eat\\u00e9s")
#     Chi2_text  <- stringi::stri_unescape_unicode("Prob. du Chi\\u00b2")
#
#     general_title <- dplyr::case_when(
#       ! stringr::str_detect(rlang::quo_name(var1), "^no_var" ) &
#         ! stringr::str_detect(rlang::quo_name(var2), "^no_var" )
#       ~ stringr::str_c(rlang::quo_name(var1), " par ", rlang::quo_name(var2) ),
#
#       stringr::str_detect(rlang::quo_name(var1), "^no_var" )
#       ~ rlang::quo_name(var2),
#
#       stringr::str_detect(rlang::quo_name(var2), "^no_var" )
#       ~ rlang::quo_name(var1)    )
#
#     if (accelerate == FALSE) {
#       #if (multicols == FALSE & multirows == FALSE) {
#
#
#       #Chi2 test (remove cols or lines with just zeros) :
#       if (no_var2 == FALSE & no_var1 == FALSE) {
#         pvalue <- wtable %>%
#           tab_draw(n, row_var = !!var1, col_var = !!var2, tab_var = !!var3,
#                   tot = "no", totaltab = stringr::str_replace(totaltab, "line", "no"),
#                   keep_unused_levels = keep_unused_levels) %>% #, col_var_sort = col_var_sort
#           purrr::map(~ dplyr::mutate(., dplyr::across(where(is.numeric), as.double)) %>%
#                        tibble::column_to_rownames(rlang::quo_name(var1)) %>%
#                        dplyr::select_if(colSums(.) != 0) %>%
#                        dplyr::filter(rowSums(.) != 0)  ) %>%
#           purrr::map(purrr::possibly(purrr::quietly(~ stats::chisq.test(.)),
#                                      tibble::tibble(warnings = "", result = tibble::tibble(p.value = NA_real_)) ) )
#         pvalue_warning <- pvalue %>% purrr::map(~ .$warnings) %>%
#           purrr::map_if(purrr::map_lgl(., ~ length(.) == 0), ~ "")
#         pvalue <- pvalue %>%
#           purrr::map(~ .$result) %>% purrr::map_dbl(~ .$p.value) %>%
#           as_pct(digits = 6)
#         if (no_var3 == FALSE & totaltab[1] == "line") {
#           pvalue %<>% append(c("Ensemble" = pct(NA_real_)))
#           pvalue_warning %<>% append("")
#         }
#
#       } else { #If there is no var2
#         pvalue <- purrr::map_int(1:length(tabs), ~ 0L) %>% as_pct()
#         pvalue_warning <- purrr::map_chr(1:length(tabs), ~ "")
#       }
#
#       pvalue_Chi2 <-
#         dplyr::summarise(dplyr::group_by(wtable, !!var3),
#                          !!count_text := dplyr::first(.tot3),
#                          "Variance" = dplyr::first(Vnuage), .groups = "drop") %>%
#         dplyr::mutate_at(3, ~ set_digits(., 5)) %>%
#         tibble::add_column(!!Chi2_text := pvalue,
#                            "warning" = pvalue_warning) %>%
#         dplyr::rename_at(1, ~ "Tableaux")
#       if (no_var3 == FALSE & totaltab[1] == "no") pvalue_Chi2 <-
#         pvalue_Chi2[-nrow(pvalue_Chi2),]
#       if (no_var3 == TRUE) pvalue_Chi2 %<>% dplyr::mutate_at(1, ~ general_title)
#       pvalue_Chi2 %<>% dplyr::mutate_at(dplyr::vars(1), ~ dplyr::if_else(
#         stringr::str_detect(warning, "incorrect"),
#         stringr::str_c(., " (!)"),
#         as.character(.))) %>%
#         dplyr::select(-warning) #%>% dplyr::mutate_at(1, ~dplyr::if_else(`Prob. du Chi\\u00b2` > 0.5, crayon::red(.), crayon::green(.)))
#
#
#     } else { # if (accelerate == TRUE)
#       pvalue <- purrr::map_dbl(1:length(tabs), ~ NA_real_) %>% as_pct()
#       pvalue_Chi2 <-
#         dplyr::summarise(dplyr::group_by(wtable, !!var3),
#                          !!count_text := as_decimal(NA_real_),
#                          "Variance" = as_decimal(NA_real_), .groups = "drop") %>%
#         dplyr::mutate_at(3, ~ set_digits(., 5))
#
#       if (no_var3 == FALSE & totaltab[1] == "no") pvalue_Chi2 <-
#         pvalue_Chi2[-nrow(pvalue_Chi2),]
#       pvalue_Chi2 %<>% tibble::add_column(!!Chi2_text := pvalue) %>%
#         dplyr::rename_at(1, ~ "Tableaux")
#       if (no_var3 == TRUE) pvalue_Chi2 %<>% dplyr::mutate_at(1, ~ general_title)
#     }
#
#     if (force_unique_table == TRUE & length(tabs) >= 2) { #Destroy class tab
#       tabs <- tabs %>%
#         purrr::map_if(1:length(.) != length(.),
#                       ~ tibble::add_row(., !!var1 := factor(
#                         strrep("_", min(max(stringr::str_length(dplyr::pull(.x, 1)),
#                                             na.rm = TRUE), 30)))) %>%
#                         dplyr::mutate_at(dplyr::vars(tidyselect::any_of("|")),
#                                          ~ tidyr::replace_na(., " "))  ) %>% #There were unbreakable space ??
#         dplyr::bind_rows() %>%
#         new_single_tab(nrow = nrow(.), perc = perc,
#                         pvalue_Chi2 = pvalue_Chi2, total_table = FALSE,
#                         subtext = subtext, force_unique_table = TRUE) %>%
#         list() %>% magrittr::set_names(general_title)
#     } else { #If multiple tables
#       tabs <- tabs %>%
#         purrr::modify2(dplyr::group_split(dplyr::rowwise(pvalue_Chi2))[1:length(.)],
#                     ~ `attr<-`(.x, "pvalue_Chi2", .y)) #%>%
#         #magrittr::set_attributes(attributes(tabs))
#     }
#
#
#
#     #Set metadatas :
#     # Many where put into tabs while changing their classes to "single_tab"
#     #  and "tab" (tab_draw function).
#     # Now we want to add attribute to the object of class "tab".
#
#     #General attributes, always attached to the tab
#     result_var <-  c("result_base_var"     = rlang::quo_name(result_base_var) )
#
#     # if (multicols == TRUE | multirows == TRUE) sup_cols <- sup_rows <- NULL
#
#     args_news <- list(
#       "original_data_name" = data_name,
#       "show_na" = show_na,
#       "minimum_headcount" = minimum_headcount,
#       "digits" = digits,
#       "cleannames" = cleannames,
#       "rare_to_other"= rare_to_other,
#       "another_total" = another_total,
#       "sup_contrib" = sup_contrib #,
#       #"confidence_intervals" = confidence_intervals,
#       #"conf_level" = conf_level,
#     )
#
#
#     args_from_tab_draw <- tabs %>%
#       purrr::pluck(purrr::attr_getter("args")) %>%
#       purrr::discard(names(.) %in% names(args_news))
#
#     tabs <- tabs %>%
#       `attr<-`("pvalue_Chi2", pvalue_Chi2) %>%
#       `attr<-`("args", append(args_from_tab_draw, args_news)) %>%
#       `attr<-`("result_var", result_var)
#
#     #If unique table, print the single_tab, and attach the tab in attribute
#     if (length(tabs) == 1) {
#       tabs <- tabs[[1]] %>% `attr<-`("tab", tabs) %>%
#         `attr<-`("is_unique_table", TRUE)
#     }
#
#     #if (force_unique_table == TRUE){ tabs %<>% purrr::map(~ dplyr::rename_at(., dplyr::vars(1), ~ rlang::quo_name(var1)))
#     #tabs %<>% purrr::map(~ dplyr::rename_at(., dplyr::vars(1), ~ title) )
#
#     # if (!is.null(original_tablist)) {
#     #   if (is_tab(original_tablist)) {
#     #     tabs <- append(list(original_tablist), list(tabs))
#     #   } else {
#     #     tabs <- append(original_tablist, list(tabs))
#     #   }
#     # }
#
#     return(tabs)
#   }
#
#
#
#
#
#
# # data <- dat2
# # dependent_var <- rlang::expr(PR0)
# # explanatory_vars <- active_vars
# # tab_var <- rlang::expr()
# # wt <- rlang::expr(row.w)
# # transpose_table = FALSE
# # only_first_level = TRUE
# # not_last_level = TRUE
# # totaltab = c("table", "line", "no")
# # show_na = TRUE
# # drop_sup_na = FALSE
# # digits = 0
# # cleannames = FALSE
# # subtext <- ""
# # sort_by = "no"
# # accelerate = FALSE
#
# #À ajouter :       - En dessous, un tableau des variances par variable explicative (et tab_var) ?
#
# #' Multiple crosstabs
# #' @description Cross one variable with many others, in colums by default,
# #'  or in rows with \code{transpose_table = TRUE}. Another variable can be used
# #'  to produce as many crosstabs as it has levels. Wrapper around \code{tabw}.
# #'
# #' @param data A data frame.
# #' @param dependent_var A single dependent variable, which by default is the row
# #' variable (see \code{transpose_table}).
# #' @param explanatory_vars A character vector of variables to be crossed with
# #' \code{dependent_var}. They can be factor/character, but also numeric (in
# #' which case a \code{\link[stats]{weighted.mean}} is calculated for each row).
# #' @param tab_var A table is made for each level in \code{tab_var} :
# #' leave empty to make a simple crosstab.
# #' @param wt A weight variable, of class numeric. Leave empty for unweighted
# #'  results.
# #' @param transpose_table When set to \code{TRUE}, \code{dependent_var} goes
# #' in columns and \code{explanatory_vars} in rows.
# #' @param only_first_level,not_last_level By default, only the first
# #'  level of each supplementary variable is printed : it works well when there
# #'  is only two levels. When \code{only_first_level} is set to \code{FALSE},
# #'  the last level of each variable is still removed, because it usually brings
# #'  no more information. To take advantage of this feature,
# #'  use \code{\link[forcats]{fct_relevel}}
# #'  to place "negative" levels (expressing the lack of something) at the end.
# #'  To print all levels, also set \code{not_last_level} to \code{FALSE}.
# #' @param totaltab Only useful when \code{var3} is provided. \code{"table"}
# #'  means that a total table will be created. \code{"line"} means it will be
# #'  reduced to a single row. \code{"no"}  means it will be totally removed.
# #' @param show_na Set to \code{FALSE} to exclude individuals with \code{NA} at
# #'  \code{dependent_var} or \code{tab_var}.
# #' @param drop_sup_na Set to \code{TRUE} to remove all individuals
# #' with \code{NA} in at least one of \code{explanatory_vars}.
# #' @param digits The number of digits to print, as an integer.
# #' @param cleannames Set to \code{TRUE} to clean levels names, by removing
# #' prefix numbers like "1-", and text in parenthesis.
# #' @param subtext A character vector to print legend rows under the
# #' (list of) table(s) in \code{\link{tab_xl}}
# #' @param sort_by A variable to sort rows in each table with. It must be among
# #'  \code{explanatory_vars}.
# #' @param minimum_headcount The minimum unweighted count in each row/col.
# #'  Any row/col with less count will be printed in grey in \code{\link{tab_xl}}.
# #' @param rare_to_other When set to \code{TRUE}, levels with less count
# #' than minimum_headcount will be merged into an "Other" level.
# #'
# #' @return When \code{var3} is empty, a single table with
# #' class \code{\link{single_tab}}, which is a special
# #'  \code{\link[tibble]{tibble}} with adapted printing method.
# #'  When \code{var3} is provided, a list of single tables, with class
# #'   \code{\link{tab}} (a list of \code{\link[tibble]{tibble}}).
# #'   The columns are of class pct, with a names column of
# #'   class factor. You can then modify tables with any functions
# #'   with \code{\link{tab_map}}.
# #' @export
# #'
# #' @examples
# #' tab_multi(dplyr::storms, category, explanatory_vars = c("pressure", "wind"))
# #'
# #' tab_multi(forcats::gss_cat, year, explanatory_vars = c("race", "marital"),
# #'          only_first_level = FALSE, not_last_level = FALSE)
# #'
# #' \dontrun{
# #'   dplyr::storms %>%
# #'     tab_multi(category, c("pressure", "wind"), transpose_table = TRUE) %>%
# #'     tab_xl()
# #' }
# tab_multi <- function(data, dependent_var, explanatory_vars, tab_var, wt,
#                      transpose_table = FALSE, only_first_level = TRUE, not_last_level = TRUE,
#                      totaltab = c("table", "line", "no"), show_na = TRUE, drop_sup_na = FALSE,
#                      digits = 0, cleannames = FALSE, subtext, sort_by = "no",
#                      minimum_headcount = 30, rare_to_other = FALSE) { #Use  tidydots ?
#
#   # if (is.data.frame(data) | ! is_tab(data)) {
#   #   original_data <- data
#   #   original_tablist <- NULL
#
#   data_name <- substitute(data) %>% as.character() %>% .[length(.)]
#   if (data_name == ".") { #Find original name if data has been piped.
#     data_name <- get_orig_name(data)
#     data_name <- stringr::str_remove(data_name, "^[^\\$]+\\$")
#   }
#   # }
#
#   # if (is_tab(data) | all(purrr::map_lgl(data, ~ is_tab(.)))) {
#   #   # if (force_unique_table == TRUE){
#   #   #   stop("Cannot use tabw with pipe/from tab with force_unique_table == TRUE") }
#   #   original_data <- NULL
#   #   original_tablist <- data
#   #   if (is_tab(data)) {
#   #     original_args <- purrr::pluck(data, purrr::attr_getter("args"))
#   #   } else {
#   #     original_args <- purrr::pluck(data[[1]], purrr::attr_getter("args"))
#   #   }
#   #
#   #   if (missing(wt) & !is.na(original_args$wt) ) wt <-         original_args$wt
#   #   if (missing(show_na) )             show_na <-              original_args$show_na
#   #   if (missing(totaltab) )            totaltab <-             original_args$totaltab
#   #   if (missing(digits) )              digits <-               original_args$digits
#   #   if (missing(cleannames) )          cleannames <-           original_args$cleannames
#   #   if (missing(only_first_level) )    only_first_level <-     original_args$only_first_level
#   #   if (missing(drop_sup_na) )         drop_sup_na <-          original_args$drop_sup_na
#   #   if (missing(subtext) )             subtext <-              original_args$subtext
#   #
#   #   data <- original_args$original_data
#   #   data_name <- original_args$original_data_name
#   # }
#   # if (!("data.frame" %in% class(data)) & ! is_tab(data)) stop("data is of the wrong type")
#
#
#
#   #"Auto" settings, options incompatibilities and warnings
#   if (missing(subtext) ) subtext <- NA_character_
#
#   if (!missing(sort_by) & (class(sort_by) != "character" | length(sort_by) > 2 |
#                            ifelse(is.na(sort_by[2] != "desc"), FALSE, sort_by[2] != "desc") )
#   ) stop("sort_by must be a character vector of length 1 (or 2 with 'desc')")
#
#   if (missing(dependent_var)) stop("no dependent var")
#
#     if (transpose_table == FALSE) {
#       var1 <- rlang::ensym(dependent_var)
#       data %<>% dplyr::mutate(no_var2 = factor("n"))
#       var2 <- rlang::expr(no_var2)
#     } else {
#       var2 <- rlang::ensym(dependent_var)
#       data %<>% dplyr::mutate(no_var1 = factor("n"))
#       var1 <- rlang::expr(no_var1)
#     }
#
#
#   if (missing(tab_var)) {
#     data %<>% dplyr::mutate(no_var3 = factor(" "))
#     var3 <- rlang::expr(no_var3)
#   } else {
#     var3 <- rlang::ensym(tab_var)
#     if (as.character(var3) %in% c("NA", "NULL", "no")) {
#       data %<>% dplyr::mutate(no_var3 = factor(" "))
#       var3 <- rlang::expr(no_var3)
#     }
#   }
#
#   if (missing(wt)) {
#     data %<>% dplyr::mutate(no_weight = 1)
#     wt <- rlang::expr(no_weight)
#   } else {
#     wt <- rlang::ensym(wt)
#     if (as.character(wt) %in% c("NA", "NULL", "no")) {
#       data %<>% dplyr::mutate(no_weight = 1)
#       wt <- rlang::expr(no_weight)
#     }
#   }
#
#   data <- data %>%
#     tab_prepare(!!var1, !!var2, !!var3,
#                 show_na = show_na, cleannames = cleannames,
#                 rare_to_other = rare_to_other, minimum_headcount = minimum_headcount) %>%
#     tab_sup_prepare(!!!rlang::syms(explanatory_vars),
#                 drop_sup_na = drop_sup_na,
#                 cleannames = cleannames,
#                 rare_to_other = rare_to_other, minimum_headcount = minimum_headcount)
#
#   perc <- if (transpose_table) {"col"} else {"row"}
#   tot  <- if (transpose_table) {"row"} else {"col"}
#
#   sup_list <- if (transpose_table) {
#     tab_make_sup_list(data, sup_rows = explanatory_vars)
#   } else {
#     tab_make_sup_list(data, sup_cols = explanatory_vars)
#   }
#
#   #data %>% purrr::map(~ is.na(.) %>% which() %>% length()) %>% print()
#
#
#   wtable <- data %>%
#     tab_sup_df(!!var1, !!var2, !!var3, !!wt, perc = perc,
#                sup_list = sup_list,
#                only_first_level = only_first_level,
#                not_last_level = not_last_level,
#                digits = digits) %>% #tot = c("row", "col")
#     tab_sort_rows(sort_by = sort_by)
#
#   if (transpose_table) {
#     tabs <-  wtable %>%
#       tab_draw(pct, res, .SUP, !!var2, !!var3,
#                zone = "sup_rows", totaltab = totaltab[1], #tot = c("row", "col")
#                subtext = subtext) %>%  # keep_unused_levels = FALSE
#       purrr::map(~ dplyr::rename_at(., length(colnames(.)), ~ "Ensemble"))
#   } else {
#     tabs <-  wtable %>%
#       tab_draw(pct, res, !!var1, .SUP, !!var3,
#               zone = "sup_cols", totaltab = totaltab[1], #tot = c("row", "col")
#               subtext = subtext) #%>% purrr::map(~ dplyr::rename(., Ensemble = Total))
#
#   }
#
#
#
#
#   result_var <- c("result_base_var" = "pct",
#                   "result_sup_text_var" = "pct",
#                   "result_sup_num_var" = "res")
#
#   args_new <-  list("sup_cols"         = sup_list$sup_cols,
#                     "sup_rows"         = sup_list$sup_rows,
#                     "multicols"        = ! transpose_table,
#                     "multirows"        = transpose_table,
#                     "sup_contrib"      = FALSE,
#                     "another_total"    = FALSE,
#                     "sup_cols_num"     = sup_list$sup_cols_num,
#                     "sup_rows_num"     = sup_list$sup_rows_num,
#                     "only_first_level" = only_first_level,
#                     "not_last_level"   = not_last_level,
#                     "drop_sup_na"      = drop_sup_na,
#                     "minimum_headcount" = minimum_headcount,
#                     "rare_to_other"= rare_to_other)
#
#
#   args_old <- tabs %>% purrr::pluck(purrr::attr_getter("args"))
#   args_old <- args_old %>% purrr::discard(names(args_old) %in% names(args_new))
#
#
#   # if (multicols == TRUE) {
#
#   # }
#   #
#   # if (multirows == TRUE) {
#   #   tabs <- wtable %>%
#   #     tab_draw(pct, res, .SUP, !!var2, !!var3,
#   #             zone = "sup_rows", tot = tot, totaltab = totaltab[1], #perc = "col",
#   #             keep_unused_levels = keep_unused_levels, subtext = subtext) %>%
#
#   # }
#
#
#   # No need :
#   # count_text <- stringi::stri_unescape_unicode("Individus enqu\\u00eat\\u00e9s")
#   # Chi2_text  <- stringi::stri_unescape_unicode("Prob. du Chi\\u00b2")
#   #
#   # #else { # If multicols or multirows
#   # pvalue <- purrr::map_dbl(1:length(tabs), ~ NA_real_) %>% as_pct()
#   # pvalue_Chi2 <-
#   #   dplyr::summarise(dplyr::group_by(wtable, !!var3),
#   #                    !!count_text := dplyr::first(.tot3),
#   #                    "Variance" = as_decimal(NA_real_), .groups = "drop") %>%
#   #   dplyr::mutate_at(3, ~ set_digits(., 5))
#   #
#   # if (no_var3 == FALSE & totaltab[1] == "no") pvalue_Chi2 <- pvalue_Chi2[-nrow(pvalue_Chi2),]
#   # pvalue_Chi2 %<>% tibble::add_column(!!Chi2_text := pvalue) %>%
#   #   dplyr::rename_at(1, ~ "Tableaux")
#   # if (no_var3 == TRUE) pvalue_Chi2 %<>% dplyr::mutate_at(1, ~ general_title)
#   # #}
#
#
#   tabs <- new_tab(tabs, args = append(args_old, args_new), wtable = wtable,
#                    result_var = result_var)
#
#   #Si tableau unique, afficher le single_tab, et attacher le tab en attribut
#   if (length(tabs) == 1) {
#     tabs <- tabs[[1]] %>% `attr<-`("tab", tabs) %>%
#       `attr<-`("is_unique_table", TRUE)
#   }
#   return(tabs)
# }
#
#
#
# #Decomposed functions ----------------------------------------------------------
#
#
#
#
# #' Make dataframe necessary to draw tables
# #'
# #' @param dat A data frame.
# #' @param var1,var2,var3 \code{var1} is the row variable. \code{var2} is the
# #' column variable. A table is made for each level in \code{var3} :
# #' leave this table variable empty to make a simple crosstab. All variables
# #' will be converted to factor.
# #' @param wt A weight variable, of class numeric. Leave empty for unweighted
# #'  results.
# #' @param perc Type of percentages. \code{"no"}, \code{"row"} and \code{"col"}
# #' are self-evident. \code{"all"} print frequencies for each table.
# #' If \code{var3} is provided, \code{"all_tabs"} calculate the proportion
# #' of each value in the total population.
# #' @param digits The number of digits to print, as an integer.
# #' @param sort_by A variable to sort rows in each table with. It must be one
# #'  of the principal or supplementary column variables.
# #' @param accelerate If \code{TRUE} makes the function faster, but produces less
# #'  metadata (no Chi2, unweighted counts, contributions of cells to variance).
# #'
# #' @return A dataframe of class \code{\link{tab_df}}, with data and metadata
# #' needed to print tables with \code{\link{tab_draw}} (or directly
# #'  \code{\link{tab_xl}} if you want default values for \code{\link{tab_draw}}).
# #' @export
# #'
# #' @examples
# #' tab_df(forcats::gss_cat, marital, race, perc = "row")
# #'
# #' \dontrun{
# #' tab_df(forcats::gss_cat, marital, race, perc = "col") %>%
# #'   tab_xl()
# #' }
# tab_df <- function(dat, var1, var2, var3, wt,
#                       perc = c("no", "row", "col", "all", "all_tabs"),
#                       #keep_unused_levels = FALSE,
#                       #minimum_headcount = 30,
#                       digits = 0L,
#                       sort_by = "no",
#                       #sup_list,
#                       #only_first_level = TRUE, not_last_level = TRUE,
#                       #another_total = FALSE,
#                       #multicols = FALSE, multirows = FALSE,
#                       #confidence_intervals = FALSE, design_effect = TRUE, conf_level = 0.95,
#                       accelerate = FALSE
# ) {
#   #Ajouter :
#   #          - Pour les variables numeriques, choix de la fonction (pas seulement moyenne ; difficile CI)
#   #          - Eclater en plusieurs fonctions pour pouvoir recalculer une valeur au besoin ?
#
#   if (missing(var1)) {
#     dat %<>% dplyr::mutate(no_var1 = factor("n"))
#     var1 <- rlang::expr(no_var1)
#   } else {
#     var1 <- rlang::ensym(var1)
#   }
#
#   if (missing(var2)) {
#     dat %<>% dplyr::mutate(no_var2 = factor("n"))
#     var2 <- rlang::expr(no_var2)
#   } else {
#     var2 <- rlang::ensym(var2)
#   }
#
#   if (missing(var3)) {
#     dat %<>% dplyr::mutate(no_var3 = factor(" "))
#     var3 <- rlang::expr(no_var3)
#   } else {
#     var3 <- rlang::ensym(var3)
#   }
#
#   if (missing(wt)) {
#     dat %<>% dplyr::mutate(no_weight = 1)
#     wt <- rlang::expr(no_weight)
#   } else {
#     wt <- rlang::ensym(wt)
#   }
#
#   datbase <- dat
#
#   dat <- dat %>% dplyr::select(!!var1, !!var2, !!var3, !!wt) %>%
#     dplyr::filter(!(is.na(!!var1)|(is.na(!!var2))|(is.na(!!var3)))) %>%
#     dplyr::mutate(!!wt := as.numeric(!!wt))
#
#   if (rlang::quo_name(var1) == "no_var1") {no_var1 <- TRUE} else {no_var1 <- FALSE}
#   if (rlang::quo_name(var2) == "no_var2") {no_var2 <- TRUE} else {no_var2 <- FALSE}
#   if (rlang::quo_name(var3) == "no_var3") {no_var3 <- TRUE} else {no_var3 <- FALSE}
#
#
#
#
#
#   #Note : to keep order of levels with dplyr::arrange(), all text vars must always stay factors.
#
#   #Faire les group_by une seule fois car ils demandent du temps de calcul :
#   dat_group123 <- dplyr::group_by(dat, !!var1, !!var2, !!var3, .drop = FALSE)
#
#   #Base tab (weighted and unweighted) :
#   if (accelerate == FALSE) {
#     wtable <- dat_group123 %>% dplyr::summarise(n =dplyr::n(), weighted_n = sum(!!wt), .groups = "drop")
#   } else {
#     wtable <- dat_group123 %>% dplyr::summarise(weighted_n = sum(!!wt), .groups = "drop")
#   }
#   wtable %<>% dplyr::mutate(.zone = factor("base"), .TYPE = factor("factor")  ) %>%
#     dplyr::select(.zone, !!var3, tidyselect::everything()) %>% dplyr::arrange(!!var3)
#
#   #Total tab
#   if (no_var3 == FALSE) {
#     wtable %<>% dplyr::group_by(!!var1, !!var2)
#     if (accelerate == FALSE){
#       wtable %<>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var3 := factor("Total"), .TYPE = factor("factor"),
#                                           n = sum(n), weighted_n = sum(weighted_n), .groups = "drop"))
#     } else {
#       wtable %<>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var3 := factor("Total"), .TYPE = factor("factor"),
#                                           weighted_n = sum(weighted_n), .groups = "drop"))
#     }
#   }
#
#   wtable %<>% dplyr::group_by(!!var3, !!var1) %>% dplyr::mutate(.wtot1 = sum(weighted_n))
#   if (accelerate == FALSE) wtable %<>% dplyr::mutate(.tot1 = sum(n), nbrow =dplyr::n() )
#
#
#   wtable %<>% dplyr::group_by(!!var3, !!var2) %>% dplyr::mutate(.wtot2 = sum(weighted_n))
#   if (accelerate == FALSE) wtable %<>% dplyr::mutate(.tot2 = sum(n), nbcol =dplyr::n() )
#
#   wtable %<>% dplyr::group_by(!!var3) %>% dplyr::mutate(.wtot3 = sum(weighted_n))
#   if (accelerate == FALSE) wtable %<>% dplyr::mutate(.tot3 = sum(n))
#
#
#   if (perc[1] == "all_tabs") wtable %<>%
#     dplyr::mutate(tottab = !!var3 == "Total") %>% dplyr::group_by(tottab) %>%
#     dplyr::mutate(.totn = sum(n), .wtotn = sum(weighted_n)) %>%
#     dplyr::select(-wn2) %>% dplyr::ungroup() %>% dplyr::select(-tottab)
#
#
#   if (accelerate == FALSE) {
#     if (perc[1] == "all_tabs") {
#       wtable %<>%
#         dplyr::group_by(!!var3, !!var1) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var2 := factor("Total"),
#                                           n = dplyr::first(.tot1), weighted_n = dplyr::first(.wtot1), .TYPE = factor("factor"),
#                                           .tot1 = dplyr::first(.tot1), .wtot1 = dplyr::first(.wtot1), nbrow = dplyr::first(nbrow),
#                                           .tot2 = dplyr::first(.tot3), .wtot2 = dplyr::first(.wtot3), nbcol = dplyr::first(nbcol),
#                                           .tot3 = dplyr::first(.tot3), .wtot3 = dplyr::first(.wtot3),
#                                           .totn = dplyr::first(.totn), .wtotn = dplyr::first(.wtotn), .groups = "drop")) %>%
#         dplyr::group_by(!!var3, !!var2) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var1 := factor("Total"),
#                                           n = dplyr::first(.tot2), weighted_n = dplyr::first(.wtot2), .TYPE = factor("factor"),
#                                           .tot1 = dplyr::first(.tot3), .wtot1 = dplyr::first(.wtot3), nbrow = dplyr::first(nbrow),
#                                           .tot2 = dplyr::first(.tot2), .wtot2 = dplyr::first(.wtot2), nbcol = dplyr::first(nbcol),
#                                           .tot3 = dplyr::first(.tot3), .wtot3 = dplyr::first(.wtot3),
#                                           .totn = dplyr::first(.totn), .wtotn = dplyr::first(.wtotn), .groups = "drop"))
#     } else { # perc != "all_tabs"
#       wtable %<>%
#         dplyr::group_by(!!var3, !!var1) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var2 := factor("Total"),
#                                           n = dplyr::first(.tot1), weighted_n = dplyr::first(.wtot1), .TYPE = factor("factor"),
#                                           .tot1 = dplyr::first(.tot1), .wtot1 = dplyr::first(.wtot1), nbrow = dplyr::first(nbrow),
#                                           .tot2 = dplyr::first(.tot3), .wtot2 = dplyr::first(.wtot3), nbcol = dplyr::first(nbcol),
#                                           .tot3 = dplyr::first(.tot3), .wtot3 = dplyr::first(.wtot3), .groups = "drop")) %>%
#         dplyr::group_by(!!var3, !!var2) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var1 := factor("Total"),
#                                           n = dplyr::first(.tot2), weighted_n = dplyr::first(.wtot2), .TYPE = factor("factor"),
#                                           .tot1 = dplyr::first(.tot3), .wtot1 = dplyr::first(.wtot3), nbrow = dplyr::first(nbrow),
#                                           .tot2 = dplyr::first(.tot2), .wtot2 = dplyr::first(.wtot2), nbcol = dplyr::first(nbcol),
#                                           .tot3 = dplyr::first(.tot3), .wtot3 = dplyr::first(.wtot3), .groups = "drop"))
#     }
#
#   } else { # if (accelerate == TRUE)
#     if (perc[1] == "all_tabs") {
#       wtable %<>% dplyr::group_by(!!var3, !!var1) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var2 := factor("Total"),
#                                           weighted_n = dplyr::first(.wtot1), .TYPE = factor("factor"),
#                                           .wtot1 = dplyr::first(.wtot1), .wtot2 = dplyr::first(.wtot3), .wtot3 = dplyr::first(.wtot3),
#                                           .wtotn = dplyr::first(.wtotn), .groups = "drop")) %>%
#         dplyr::group_by(!!var3, !!var2) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var1 := factor("Total"),
#                                           weighted_n = dplyr::first(.wtot2), .TYPE = factor("factor"),
#                                           .wtot1 = dplyr::first(.wtot3), .wtot2 = dplyr::first(.wtot2),.wtot3 = dplyr::first(.wtot3),
#                                           .wtotn = dplyr::first(.wtotn), .groups = "drop"))
#     } else {
#       wtable %<>% dplyr::group_by(!!var3, !!var1) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var2 := factor("Total"),
#                                           weighted_n = dplyr::first(.wtot1), .TYPE = factor("factor"),
#                                           .wtot1 = dplyr::first(.wtot1), .wtot2 = dplyr::first(.wtot3), .wtot3 = dplyr::first(.wtot3), .groups = "drop")) %>%
#         dplyr::group_by(!!var3, !!var2) %>%
#         dplyr::bind_rows(dplyr::summarise(., .zone = factor("base"), !!var1 := factor("Total"),
#                                           weighted_n = dplyr::first(.wtot2), .TYPE = factor("factor"),
#                                           .wtot1 = dplyr::first(.wtot3), .wtot2 = dplyr::first(.wtot2),.wtot3 = dplyr::first(.wtot3), .groups = "drop"))
#     }
#   }
#   wtable %<>% dplyr::ungroup() %>% dplyr::arrange(!!var3, !!var1)
#
#   if (no_var3 == FALSE) wtable %<>%
#     dplyr::mutate(!!var3 := suppressWarnings(
#       forcats::fct_recode(!!var3, "Ensemble" = "Total"))
#     )
#
#
#   #Percentages:
#   if (perc[1] == "row") {
#     perc_wtot <- rlang::expr(.wtot1)
#   } else if (perc[1] == "col")            {
#     perc_wtot <- rlang::expr(.wtot2)
#   } else if (perc[1] == "all") {
#     perc_wtot <- rlang::expr(.wtot3)
#   } else if (perc[1] == "all_tabs")       {
#     perc_wtot <- rlang::expr(.wtotn)
#   }
#   if (perc[1] != "no") wtable %<>%
#     dplyr::mutate(pct = (weighted_n/!!perc_wtot) %>%
#                     tidyr::replace_na(., 0) %>%
#                     round(7)  )
#
#
#
#   #if (another_total == TRUE) {
#   if (perc[1] %in% c("row", "no", "all", "all_tabs")) {
#     wtable %<>%
#       dplyr::mutate(an_totcol = dplyr::case_when(
#         !!var1 == "Total" & !!var2 == "Total" ~ weighted_n,
#         !!var2 == "Total"                     ~ weighted_n/.wtot2) )
#   } else if (perc[1] %in% "col") {
#     wtable %<>%
#       dplyr::mutate(an_totrow = dplyr::case_when(
#         !!var1 == "Total" & !!var2 == "Total" ~ weighted_n,
#         !!var1 == "Total"                     ~ weighted_n/.wtot1) )
#   }
#   #}
#
#   # Tab of relative contributions of cells to explained variance
#   if (accelerate == FALSE) {
#     if (no_var1 == FALSE & no_var2 == FALSE) {
#       #USE EXISTING FUNC TO BE MORE CERTAIN OF THE RESULT ? cor
#       wtable %<>%
#         dplyr::mutate(expected = (.wtot1 * .wtot2)/(.wtot3 ^ 2),
#                       spread = weighted_n/.wtot3 - expected,
#                       binding_ratio = spread/expected,
#                       ctr_abs = expected * binding_ratio ^ 2) %>%
#         dplyr::mutate_at(c("ctr_abs", "binding_ratio"), ~ tidyr::replace_na(., 0)  ) %>%
#
#         dplyr::group_by(!!var3) %>%
#         dplyr::mutate(Vnuage = sum(ctr_abs)) %>%
#
#         dplyr::group_by(!!var3, !!var2) %>%
#         dplyr::mutate(ctr_abs_var1 = sum(ctr_abs)) %>%
#
#         dplyr::group_by(!!var3, !!var1) %>%
#         dplyr::mutate(ctr_abs_var2 = sum(ctr_abs)) %>%
#
#         dplyr::ungroup() %>%
#         dplyr::mutate(ctr_abs = ifelse(!!var1 == "Total", ctr_abs_var1, ctr_abs) ) %>%
#         dplyr::mutate(ctr_abs = ifelse(!!var2 == "Total", ctr_abs_var2, ctr_abs) ) %>%
#         dplyr::mutate(ctr_abs = ifelse(!!var1 == "Total" & !!var2 == "Total", Vnuage, ctr_abs) ) %>%
#         dplyr::select(-ctr_abs_var1, -ctr_abs_var2) %>%
#
#         dplyr::mutate(ctr_no_sign = ctr_abs/Vnuage,
#                       contrib = (ctr_no_sign * sign(spread)) %>%
#                         dplyr::if_else(
#                           !!var1 == "Total" | !!var2 == "Total",
#                           ctr_no_sign,
#                           .),
#                       ctr_mean = (1/(nbrow * nbcol)) %>%
#                         dplyr::if_else(
#                           !!var1 == "Total" | !!var2 == "Total",
#                           NA_real_,
#                           .) ) %>%
#         dplyr::mutate(dplyr::across(expected:contrib,
#                                     ~ tidyr::replace_na(., 0) %>% round(7) ))
#
#
#     } else { #If there is no var2
#       wtable %<>%
#         dplyr::mutate(expected  = 0, spread  = 0, binding_ratio  = 0,
#                       ctr_abs  = 0,Vnuage  = 0, ctr_no_sign  = 0, contrib  = 0,
#                       ctr_mean = NA_real_)
#     }
#   }
#   #Supprimer variables transitoires
#   wtable %<>% dplyr::select(-tidyselect::any_of(c("nbrow", "nbcol")))
#
#
#
#
#   #STILL NEEDED ?
#
#
#   wtable %<>% dplyr::select(
#     .zone, !!var3, !!var1, !!var2,
#     tidyselect::any_of(c(".SUP_NAME", ".SUP",
#                          "pct", "moe", "resCI", "n")),
#     weighted_n,
#     tidyselect::any_of(c("moe_wn", "res", "moe_res", "contrib", "ctr_mean",
#                          "pct1", "pct2", "freq", "freqn",
#                          ".tot1", ".wtot1", ".tot2", ".wtot2", ".tot3", ".wtot3",
#                          ".totn", ".wtotn", "an_totcol", "an_totrow",
#                          "deff", "conf_level")), .TYPE,
#     tidyselect::any_of(c("expected", "spread", "binding_ratio",
#                          "ctr_abs", "Vnuage", "ctr_no_sign")),
#     tidyselect::everything())
#
#   wtable %<>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("pct", "moe", "pct1", "pct2", "freq", "freqn",
#                                                      "contrib", "ctr_mean", "expected", "spread", "binding_ratio", "ctr_no_sign")),
#                                 ~ pct(., digits = digits))) %>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("moe_wn", ".tot1", ".wtot1", ".tot2", ".wtot2",
#                                                      ".tot3", ".wtot3", ".totn", ".wtotn", "n", "weighted_n")),
#                                 ~ decimal(., digits = 0L))) %>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("ctr_abs", "Vnuage")),
#                                 ~ decimal(., digits = digits + 2L)))
#
#   #Here ?
#   #Format of calculated means : integer if none is < 0
#   if ("res" %in% colnames(wtable) ) {
#     max_quiet <- purrr::quietly(max)
#     max_mean_of_num_SUP_NAME <-
#       wtable %>% dplyr::filter(.TYPE == "num") %>% dplyr::group_by(.SUP_NAME) %>%
#       dplyr::summarise(mean_res = mean(res, na.rm = TRUE), .groups = "drop") %>% dplyr::pull(mean_res) %>% max_quiet() %>%  .$result
#     if (max_mean_of_num_SUP_NAME < 0) {
#       wtable %<>% dplyr::mutate(dplyr::across(tidyselect::any_of(c("res", "moe_res")), ~ decimal(., digits = 3L)) )
#     } else {
#       wtable %<>% dplyr::mutate(dplyr::across(tidyselect::any_of(c("res", "moe_res")), ~ decimal(., digits = 0L)) )
#     }
#   }
#
#   wtable <- new_tab_df(wtable, perc[1], data = datbase, wt = as.character(wt))
#
#   wtable <- tab_sort_rows(wtable, sort_by, !!var1, !!var2, !!var3)
#
#   return(wtable)
# }
#
#
# #From the database to actual tables
# #' Draw tables from dataframe
# #' @description Draw tables from \code{dataframe} of class \code{tab_df}, made
# #' with \code{\link{tab_df}}.
# #'
# #' @param wtable A dataframe with class \code{tab_df}.
# #' @param result_text The variable containing the results to print with factors.
# #' When empty, the \code{weighted_n} variable is taken
# #' with no percentages, the \code{pct} with percentages.
# #' @param result_num The variable containing the results to print with
# #' numeric variables. When empty, \code{res} variable is taken.
# #' @param row_var The row variable. When empty, takes the \code{var1} of
# #' the \code{tab_df}.
# #' @param col_var The column variable. When empty, takes the \code{var2} of
# #' the \code{tab_df}.
# #' @param tab_var The table variable. When empty, takes the \code{var3} of
# #' the \code{tab_df}.
# #' @param zone The type of table to draw :
# #' \itemize{
# #' \item \code{"base"} is the standard crosstab
# #' \item \code{"sup_cols"} is the table of supplementary columns
# #' \item \code{"sup_rows"} is the table of supplementary rows
# #' }
# #' @param tot  \code{"row"} add a total row, \code{"col"}
# #' a total column, and \code{"all"} and \code{c("row", "col")} stand for both.
# #' \code{"no"} removes all totals.
# #' @param totaltab Only useful when \code{var3} is provided. \code{"table"}
# #'  means that a totaltable will be created. \code{"line"} means it will be
# #'  reduced to a single row. \code{"no"} means it will be totally removed.
# #' @param keep_unused_levels Set to \code{TRUE} to keep empty levels of factors.
# #' @param subtext A character vector to print legend rows under the
# #' (list of) table(s) in \code{\link{tab_xl}}
# #' @param reverse_row_col Transpose tables, with the row variable in colums
# #' and the column variable in rows.
# #'
# #' @return A list of tables of class \code{\link{tab}},
# #' or a \code{\link{single_tab}}.
# #' @export
# #'
# #' @examples
# #' \dontrun{
# #' forcats::gss_cat %>%
# #'   tab_prepare(marital, relig, race, rare_to_other = TRUE) %>%
# #'   tab_df(marital, relig, race, perc = "col") %>%
# #'   tab_draw(totaltab = "line") %>%
# #'   tab_xl(compact = TRUE)
# #'   }
# tab_draw <-
#   function(wtable, result_text, result_num, row_var, col_var, tab_var,
#            zone = c("base","sup_cols", "sup_rows"), tot = c("row", "col"),
#            totaltab = c("table", "line", "no"), keep_unused_levels = FALSE,
#            subtext = "", reverse_row_col = FALSE) { #Remove col_var_sort (attr is enough)
#     perc <- wtable %>% purrr::pluck(purrr::attr_getter("perc"))
#     if (is.null(perc)) perc <- "no"
#
#     if (missing(result_text)) {
#       if (perc[1] == "no" & zone[1] == "base") {
#         result_text <- rlang::expr(weighted_n)
#       } else {
#         result_text <- rlang::expr(pct)
#       }
#     } else {
#       result_text <- rlang::ensym(result_text)
#     }
#
#     if (missing(result_num)) {
#       result_num <- rlang::expr(res)
#     } else {
#       result_num <- rlang::ensym(result_num)
#     }
#
#     col_var_sort <- wtable %>%
#       purrr::pluck(purrr::attr_getter("col_var_sort"))
#     if (rlang::is_null(col_var_sort)) col_var_sort <- "no"
#
#     wtable_base <- wtable
#
#     #If row, col and tab vars are missing, it selects the standard column in wtab
#     #  (var3 in second position, var1 in third, var2 in fourth)
#
#
#
#     if (missing(row_var)) {row_var <- rlang::sym(names(wtable)[3])} else {row_var <- rlang::ensym(row_var)}
#     if (missing(col_var)) {col_var <- rlang::sym(names(wtable)[4])} else {col_var <- rlang::ensym(col_var)}
#     if (missing(tab_var)) {tab_var <- rlang::sym(names(wtable)[2])} else {tab_var <- rlang::ensym(tab_var)}
#
#     wtable <-
#       wtable %>%
#       dplyr::select(.zone, .TYPE, tidyselect::any_of(c(".SUP_NAME", ".SUP")), !!tab_var, !!row_var, !!col_var,
#                     tidyselect::any_of(c(rlang::quo_name(result_text), rlang::quo_name(result_num))), weighted_n) %>%
#       dplyr::filter(.zone == zone[1])
#
#     if (keep_unused_levels == FALSE) wtable <- wtable %>%
#       dplyr::group_by(.zone, !!row_var, !!tab_var) %>%
#       dplyr::filter(!all(weighted_n == 0)) %>%
#       dplyr::ungroup() #Ok with sup_cols and sup_rows ?
#
#     total_levels <- c("Total", "Ensemble")
#     wtable %<>%
#       dplyr::filter( (!("only_totrow" %in% tot) & !(!!row_var %in% total_levels)) |                  #Keep non-totals, excepted if "only_totrow" is selected
#                        (!!row_var %in% total_levels & ("row" %in% tot | "only_totrow" %in% tot)) |   # Drop total row if "row" is not selected in tot
#                        (!!row_var %in% total_levels & !!tab_var %in% total_levels & totaltab[1] == "line") ) %>% #Keep total line of total table anyway if "totaltab = line"
#       dplyr::filter( (!("only_totcol" %in% tot) & ! (!!col_var %in% total_levels)) |                 #Keep non-totals, excepted if "only_totcol" is selected
#                        (!!col_var %in% total_levels & ("col" %in% tot | "only_totcol" %in% tot)) ) %>% # Drop total col if "col" is not selected in tot
#       dplyr::filter( !(!!tab_var %in% total_levels) |                                                 # Keep total table or total line if selected
#                        (!!tab_var %in% total_levels & totaltab[1] == "table") |
#                        (!!tab_var %in% total_levels & !!row_var %in% total_levels & totaltab[1] == "line") )
#
#     #wtable %>% View()
#
#     wtable %<>% dplyr::mutate_at(dplyr::vars(!!tab_var), ~ suppressWarnings(forcats::fct_recode(., "Ensemble" = "Total")) ) %>%
#       dplyr::mutate_at(dplyr::vars(!!row_var, !!col_var), ~ suppressWarnings(forcats::fct_recode(., "Total" = "Ensemble" )))
#     sheet_names <- levels(forcats::fct_drop(dplyr::pull(wtable, !!tab_var))) %>%
#       stringr::str_replace_all("[^[:alnum:][:punct:]]", " ") %>%
#       stringr::str_squish()
#     subtots_name <- stringr::str_c("Total ", stringr::str_to_upper(sheet_names, locale = "fr"))
#     subtots_name_named <- subtots_name %>%  purrr::map(~ magrittr::set_names("Total" , .))
#
#     #if (zone[1] == "base" ) {
#     # general_title <- dplyr::if_else(! stringr::str_detect(rlang::quo_name(col_var), "^no_var" ),
#     #                          stringr::str_c(rlang::quo_name(row_var), " par ", rlang::quo_name(col_var) ),
#     #                          rlang::quo_name(row_var))
#     general_title <- dplyr::case_when(
#       ! stringr::str_detect(rlang::quo_name(row_var), "^no_var" ) &
#         ! stringr::str_detect(rlang::quo_name(col_var), "^no_var" )
#       ~ stringr::str_c(rlang::quo_name(row_var), " par ", rlang::quo_name(col_var) ),
#
#       stringr::str_detect(rlang::quo_name(row_var), "^no_var" )
#       ~ rlang::quo_name(col_var),
#
#       stringr::str_detect(rlang::quo_name(col_var), "^no_var" )
#       ~ rlang::quo_name(row_var)    )
#     if (! stringr::str_detect(rlang::quo_name(tab_var), "^no_var" )) {
#       sheet_names <- stringr::str_c(general_title, " : ", sheet_names)
#     } else {
#       sheet_names <- rep(general_title, length(sheet_names))
#     }
#     #}
#
#
#     tab_draw_core <- function(wtable, result, row_var, col_var, tab_var, #Only quosures/exprs
#                               .sheet_names = sheet_names, .subtots_name = subtots_name,
#                               .subtots_name_named = subtots_name_named, .reverse_row_col = reverse_row_col) {
#
#       wtable %<>% dplyr::group_by(!!tab_var) %>% dplyr::group_split()
#
#       if (col_var_sort[[1]][1] != "no") {
#         wtable %<>%
#           purrr::map2(col_var_sort[1:length(wtable)],
#                       ~ dplyr::mutate_at(.x, dplyr::vars(!!row_var),
#                                          function(var) forcats::fct_relevel(var, .y)))
#         if (all(purrr::map_lgl(wtable, ~ ".SUP_NAME" %in% colnames(.) ))) {
#           wtable <-
#             purrr::map(wtable, ~ dplyr::arrange(., .zone, .TYPE, .SUP_NAME,
#                                                 !!row_var, !!col_var) )
#         } else {
#           wtable <-
#             purrr::map(wtable, ~ dplyr::arrange(., .zone, .TYPE,
#                                                 !!row_var, !!col_var) ) #Ok or bugs ?
#         }
#       }
#
#       if (.reverse_row_col == FALSE) {
#         wtable %>%
#           purrr::map(~ tidyr::pivot_wider(., id_cols = !!row_var,
#                                           names_from = !!col_var,
#                                           values_from = !!result) ) %>%
#           purrr::map2(.subtots_name_named[1:length(.)],
#                       ~ dplyr::mutate_at(
#                         .x,
#                         dplyr::vars(1),
#                         ~ suppressWarnings(forcats::fct_recode(., !!!.y))
#                       )) %>%
#           purrr::map(~ dplyr::mutate_at(., dplyr::vars(1),
#                                         ~ forcats::fct_expand(., .subtots_name))) %>%
#           magrittr::set_names(.sheet_names[1:length(.)])
#       } else {
#         wtable %>%
#           purrr::map(~ tidyr::pivot_wider(., id_cols = !!col_var,
#                                           names_from = !!row_var,
#                                           values_from = !!result) ) %>%
#           purrr::map2(.subtots_name_named[1:length(.)],
#                       ~ dplyr::mutate_at(
#                         .x,
#                         dplyr::vars(1),
#                         ~ suppressWarnings(forcats::fct_recode(., !!!.y))
#                       )) %>%
#           purrr::map(~ dplyr::mutate_at(., dplyr::vars(1),
#                                         ~ forcats::fct_expand(., .subtots_name))) %>%
#           magrittr::set_names(.sheet_names[1:length(.)])
#       }
#     }
#
#     wtable_text <- wtable %>% dplyr::filter(.TYPE == "factor")
#     wtable_num  <- wtable %>% dplyr::filter(.TYPE == "num")
#
#     # class(wtable_text)
#     # print(row_var)
#     # print(col_var)
#     # print(tab_var)
#
#     if (nrow(wtable_text) != 0) tabs_text <- wtable_text %>%
#       tab_draw_core(result_text, row_var, col_var, tab_var)
#     if (nrow(wtable_num) != 0) tabs_num <- wtable_num %>%
#       tab_draw_core(result_num, row_var, col_var, tab_var)
#
#     if (nrow(wtable_text) != 0 & nrow(wtable_num) != 0) {
#       #tabs <- purrr::map2(tabs_text, tabs_num, ~ dplyr::full_join(.x, .y, by = rlang::quo_name(row_var)))
#       tabs <-
#         purrr::map2(tabs_text, tabs_num, purrr::quietly(~ dplyr::full_join(.x, .y))) %>%
#         purrr::map(~ .$result)
#       tabs <- tabs %>%
#         purrr::map(~ dplyr::select(.,
#                                    -tidyselect::any_of(c("Total", "Ensemble")),
#                                    tidyselect::everything()) %>%
#                      dplyr::arrange(dplyr::across(1, ~ stringr::str_detect(
#                        ., "^Total |^TOTAL |^Ensemble |^ENSEMBLE "
#                      )))
#         )
#
#
#     } else if (nrow(wtable_text) != 0) {
#       tabs <- tabs_text
#     } else if (nrow(wtable_num) != 0) {
#       tabs <- tabs_num
#     } else {
#       tabs <- list(tibble::tibble())
#     }
#
#     tabs <-
#       purrr::pmap(list(
#         tabs,
#         rep(NA_character_, length(tabs) - 1) %>% as.list() %>%
#           purrr::splice(list(subtext)),
#         rep(FALSE, length(tabs) - 1) %>% as.list() %>%
#           purrr::splice(list(totaltab[1] %in% c("line", "table"))) ),
#         ~ new_single_tab(..1,
#                           nrow = nrow(..1),
#                           perc = perc[1],
#                           subtext = ..2,
#                           total_table = ..3)  )
#
#     args_tab_draw <- list(
#       "perc" = perc[1],
#       "keep_unused_levels" = keep_unused_levels,
#       "totals" = tot,
#       "totaltab" = totaltab[1],
#       "subtext" = subtext,
#       "multicols" = FALSE,
#       "multirows" = FALSE,
#       "sup_contrib" = FALSE,
#       "wt" = purrr::pluck(wtable_base, purrr::attr_getter("wt"))
#     )
#
#     new_tab(tabs, wtable = wtable_base, args = args_tab_draw)
#   }
#
#
#
# #Add error message when tab_sup used with tab_multi -----
#
# #' Add supplementary columns or rows to a crosstab
# #' @param data_or_tabs An object of class \code{tab} or \code{single_tab}
# #' made with \code{\link{tab}} or \code{\link{tab_draw}}, or a dataframe
# #' of class \code{tab_df} made with \code{\link{tab_df}}.
# #' @param sup_cols,sup_rows,print_sup A character vector of
# #'  supplementary column variables, or/and supplementary row variables.
# #'  They can be factor/character, but also numeric (in which case a
# #'  \code{\link[stats]{weighted.mean}} is calculated for all categories
# #'  of \code{var1}/\code{var2}). \code{sup_cols} and \code{sup_rows} won't
# #'  be printed in the results unless :
# #'  \itemize{
# #'   \item you pass the tabs to \code{\link{tab_xl}}
# #'   \item you set print_sup to \code{TRUE} : it draws a table with all
# #'   principals AND supplementary variables (confusing and not recommended).
# #' }
# #' @param only_first_level,not_last_level By default, only the first
# #'  level of each supplementary variable is printed : it works well when there
# #'  is only two levels. When \code{only_first_level} is set to \code{FALSE},
# #'  the last level of each variable is still removed, because it usually brings
# #'  no more information. To take advantage of this feature,
# #'  use \code{\link[forcats]{fct_relevel}}
# #'  to place "negative" levels (expressing the lack of something) at the end.
# #'  To print all levels, also set \code{not_last_level} to \code{FALSE}.
# #' @param sort_by A variable to sort rows in each table with. It must be one
# #'  of the principal or supplementary column variables.
# #' @param drop_sup_na Set to \code{TRUE} to remove all individuals
# #' with \code{NA} in at least one supplementary variable.
# #' @param cleannames Set to \code{TRUE} to clean levels names, by removing
# #' prefix numbers like "1-", and text in parenthesis.
# #' @param digits The number of digits to print, as an integer.
# #'
# #' @return Tables with metadata to draw supplementary rows and colums with
# #' \code{\link{tab_xl}}, or tables with printed supplementary rows/cols.
# #' @export
# #'
# #' @examples
# #' forcats::gss_cat %>%
# #'   dplyr::mutate(marital = forcats::fct_relevel(marital, "Married")) %>%
# #'   tab(relig, race, perc = "row", rare_to_other = TRUE) %>%
# #'   tab_sup(sup_cols = c("marital", "age", "tvhours"), print_sup = TRUE)
# #' \dontrun{
# #' forcats::gss_cat %>%
# #'   dplyr::mutate(marital = forcats::fct_relevel(marital, "Married")) %>%
# #'   tab(relig, race, perc = "row", rare_to_other = TRUE) %>%
# #'   tab_sup(sup_rows = c("marital", "age", "tvhours")) %>%
# #'   tab_xl()
# #' }
# tab_sup <- function(data_or_tabs,
#                     sup_cols = NULL, sup_rows = NULL,
#                     only_first_level = TRUE, not_last_level = TRUE, sort_by = "no",
#                     drop_sup_na = FALSE, cleannames = FALSE, digits = 0L,
#                     print_sup = FALSE) {
#
#   if ("tab_df" %in% class(data_or_tabs) ) {
#     wtable <- data_or_tabs
#     tabs <- tab_draw(wtable)  #row_var = !!var1, col_var = !!var2, tab_var = !!var3 #col_var_sort = col_var_sort, #perc = perc[1]
#     args <- NULL
#     #Defaults, to pass to the next tab_draw :
#     tot                <- c("row", "col")
#     totaltab           <- "table"
#     keep_unused_levels <- FALSE
#     subtext            <- ""
#
#     # #Useful somewhere ?
#     # general_title <- dplyr::case_when(
#     #   ! stringr::str_detect(rlang::quo_name(var1), "^no_var" ) & ! stringr::str_detect(rlang::quo_name(var2), "^no_var" ) ~ stringr::str_c(rlang::quo_name(var1), " par ", rlang::quo_name(var2) ),
#     #   stringr::str_detect(rlang::quo_name(var1), "^no_var" ) ~ rlang::quo_name(var2),
#     #   stringr::str_detect(rlang::quo_name(var2), "^no_var" ) ~ rlang::quo_name(var1)    )
#   } else {
#     if ("tab" %in% class(data_or_tabs) ) {
#       tabs <- data_or_tabs
#     } else if ("single_tab" %in% class(data_or_tabs)) {
#       tabs <- data_or_tabs %>% purrr::pluck(purrr::attr_getter("tab"))
#     } else {
#       stop("data is of the wrong class (neither tab, single_tab of tab_df")
#     }
#     wtable <- tabs %>% purrr::pluck(purrr::attr_getter("wtable"))
#
#     args <- tabs %>% purrr::pluck(purrr::attr_getter("args"))
#     tot                <- args$totals
#     totaltab           <- args$totaltab
#     keep_unused_levels <- args$keep_unused_levels
#     subtext            <- args$subtext
#   }
#
#   var1 <- rlang::sym(names(wtable)[3])
#   var2 <- rlang::sym(names(wtable)[4])
#   var3 <- rlang::sym(names(wtable)[2])
#   wt   <- wtable %>% purrr::pluck(purrr::attr_getter("wt")) %>% rlang::sym()
#   perc <- wtable %>% purrr::pluck(purrr::attr_getter("perc"))
#   result_var <- tabs %>% purrr::pluck(purrr::attr_getter("result_var"))
#
#   if (rlang::is_null(result_var)) {
#     if (perc[1] == "no") {
#       result_var <-  c("result_base_var" = "weighted_n")
#     } else {
#       result_var <-  c("result_base_var" = "pct")
#     }
#   }
#
#   data <- wtable %>% purrr::pluck(purrr::attr_getter("data")) %>%
#     tab_sup_prepare(!!!rlang::syms(c(sup_cols, sup_rows)),
#                 drop_sup_na = drop_sup_na,
#                 cleannames = cleannames)
#
#   sup_list <- data %>% tab_make_sup_list(sup_cols, sup_rows)
#
#   wtable_sup <-
#     tab_sup_df(data, !!var1, !!var2, !!var3, !!wt, perc,
#                  sup_list = sup_list,
#                  only_first_level = only_first_level,
#                  not_last_level = not_last_level,
#                  digits = digits, tot = tot)
#
#   wtable <- dplyr::bind_rows(wtable, wtable_sup) %>%
#     dplyr::select(.zone, !!var3, !!var1, !!var2,
#                   tidyselect::any_of(c(".SUP_NAME", ".SUP",
#                                        "pct", "moe", "resCI", "n")),
#                   weighted_n, .TYPE, tidyselect::everything())
#
#   wtable <- wtable %>% #magrittr::set_attributes(wtable_attr)
#     new_tab_df(perc = perc, wt = as.character(wt), data = data)
#
#   wtable <- tab_sort_rows(wtable, sort_by, !!var1, !!var2, !!var3)
#
#
#   wtable %>%
#     tab_draw(pct, res, !!var1, .SUP, !!var3,
#             zone = "sup_cols", tot = tot, totaltab = totaltab[1], #perc = "col",
#             keep_unused_levels = keep_unused_levels, subtext = subtext)
#
#   if (print_sup == TRUE) {
#
#     if (length(sup_cols) != 0) sup_cols_tabs <- wtable %>%
#         tab_draw(pct, res, !!var1, .SUP, !!var3,
#                 zone = "sup_cols", tot = tot, totaltab = totaltab[1], #perc = "col",
#                 keep_unused_levels = keep_unused_levels, subtext = subtext) #    wtable, row_var, col_var, tab_var, result_text, result_num,
#
#     sup_rows_condition_compatibilities <- #confidence_intervals == TRUE |
#       ! (((perc[1] == "no" | result_var[1] == "ctr_abs") & any(sup_list$sup_rows_text)) |
#            (perc[1] != "no" & result_var[1] != "ctr_abs" & any(sup_list$sup_rows_num )))
#
#     if (length(sup_rows) != 0 & sup_rows_condition_compatibilities) {
#       sup_rows_tabs <- wtable %>%
#         tab_draw(pct, res, .SUP, !!var2, !!var3,
#                 zone = "sup_rows", tot = tot, totaltab = totaltab[1], #"table", #perc = "row",
#                 keep_unused_levels = keep_unused_levels, subtext = subtext)
#     }
#
#     if (length(sup_rows) != 0 & ! sup_rows_condition_compatibilities) {
#       warning("cannot print supplementary row in console, because vector type is different from tabs columns : set print_sup = FALSE and export to Excel with tab_xl")
#     }
#
#     if (length(sup_cols) != 0) tabs <-
#       purrr::map2(purrr::map(tabs, ~ dplyr::mutate(., `>>>` = "|")), sup_cols_tabs,
#                   ~ dplyr::full_join(.x, .y, by = magrittr::set_names(c(colnames(.y)[1]), colnames(.x)[1])))
#
#     if (length(sup_rows) != 0 & sup_rows_condition_compatibilities) tabs <-
#       purrr::map2(tabs, sup_rows_tabs, ~ tibble::add_row(.x, !!var1 := factor(
#         strrep("-", min(max(stringr::str_length(dplyr::pull(.x, 1)), na.rm = TRUE), 30)))) %>%
#           dplyr::bind_rows(dplyr::rename(.y, !!var1 := .SUP)) %>%
#           dplyr::mutate_at(dplyr::vars(tidyselect::any_of(">>>")), ~ tidyr::replace_na(., " "))) #There were unbreakable space ??
#
#
#     if (length(sup_cols) != 0 & length(sup_rows) != 0) {
#       tabs %<>% purrr::map(~ `attr<-`(., "print_sup", c(TRUE, TRUE)))
#     } else if (length(sup_cols) != 0) {
#       tabs %<>% purrr::map(~ `attr<-`(., "print_sup", c(TRUE, FALSE)))
#     } else if (length(sup_rows) != 0) {
#       tabs %<>% purrr::map(~ `attr<-`(., "print_sup", c(FALSE, TRUE)))
#     }
#
#   }
#
#   result_var <- result_var %>%
#     append(c("result_sup_text_var" = "pct",
#              "result_sup_num_var" = "res"))
#
#   args_new <-  list("sup_cols"         = sup_list$sup_cols,
#                     "sup_rows"         = sup_list$sup_rows,
#                     "multicols"        = FALSE,
#                     "multirows"        = FALSE,
#                     "sup_contrib"      = FALSE,
#                     "another_total"    = FALSE,
#                     "sup_cols_num"     = sup_list$sup_cols_num,
#                     "sup_rows_num"     = sup_list$sup_rows_num,
#                     "only_first_level" = only_first_level,
#                     "not_last_level"   = not_last_level,
#                     "drop_sup_na"      = drop_sup_na            )
#
#   args_old <- purrr::discard(args, names(args) %in% names(args_new))
#
#   #Ajouter calcul Chi2 ici si la table vient d'être faite ? ----
#   tabs <- new_tab(tabs, args = append(args_old, args_new), wtable = wtable,
#                    result_var = result_var)
#
#   #Si tableau unique, afficher le single_tab, et attacher le tab en attribut
#   if (length(tabs) == 1) {
#     tabs <- tabs[[1]] %>% `attr<-`("tab", tabs) %>%
#       `attr<-`("is_unique_table", TRUE)
#   }
#
#   return(tabs)
# }
#
#
#
#
# #tab internal functions -------------------------------------------------------
#
#
#
#
# #' @keywords internal
# tab_sup_df <- function(data, var1, var2, var3, wt, perc,
#                          sup_list,
#                          only_first_level = TRUE,
#                          not_last_level = TRUE,
#                          digits = 0L,
#                          tot = c("row", "col")  #,
#                          #accelerate = FALSE,
#                          #another_total = FALSE,
#                          #multicols = FALSE, multirows = FALSE,
#
#                          #confidence_intervals = FALSE, design_effect = TRUE, conf_level = 0.95,
# ) {
#
#   var1 <- rlang::ensym(var1)
#   var2 <- rlang::ensym(var2)
#   var3 <- rlang::ensym(var3)
#   wt   <- rlang::ensym(wt)
#
#   if (rlang::quo_name(var1) == "no_var1") {no_var1 <- TRUE} else {no_var1 <- FALSE}
#   if (rlang::quo_name(var2) == "no_var2") {no_var2 <- TRUE} else {no_var2 <- FALSE}
#   if (rlang::quo_name(var3) == "no_var3") {no_var3 <- TRUE} else {no_var3 <- FALSE}
#
#   sup_cols      <-  sup_list$sup_cols
#   sup_cols_num  <-  sup_list$sup_cols_num
#   sup_cols_text <-  sup_list$sup_cols_text
#   sup_rows      <-  sup_list$sup_rows
#   sup_rows_num  <-  sup_list$sup_rows_num
#   sup_rows_text <-  sup_list$sup_rows_text
#
#   dat <- data %>%
#     dplyr::select(!!var1, !!var2, !!var3, !!wt, tidyselect::all_of(c(sup_cols, sup_rows)))
#
#   #Remove all the NAs of explanatory variables
#   #if drop_sup_na == FALSE, all factors (not numeric) where made explicit with dat_prepare :
#   #print(dplyr::filter_all(dat, ~ is.na(.)))
#
#   #dat %>% purrr::map(~ is.na(.) %>% which() %>% length()) %>% print()
#
#   dat <- dat %>% dplyr::filter_if(is.factor, ~ !is.na(.))
#
#
#
#   dat_group3 <- dat %>% dplyr::group_by(!!var3, .add = TRUE, .drop = FALSE)
#
#   if (only_first_level == TRUE) {
#     supvars_3levels <-
#       purrr::map_lgl(dat, ~ is.factor(.) & nlevels(.) >= 3) &
#       colnames(dat) %in% c(sup_cols, sup_rows)
#     if (any(supvars_3levels)) dat %<>%
#       dplyr::mutate_if(supvars_3levels,
#                        ~ forcats::fct_other(.,
#                                             keep = levels(.)[1],
#                                             other_level = "Autres"))
#   }
#
#
#
#
#
#   #Supplementary cols and rows
#   sup_tab_calc <- function(dat_group, sup_names, sup_text, .zone, confidence_intervals = FALSE) { # accelerate = FALSE,
#     # if (accelerate == FALSE) {
#     #   # if (confidence_intervals == TRUE) {
#     #   #   sup_tab_calculation <- sup_names %>%
#     #   #     purrr::map_if(sup_text, function(.x) # Character and factor vars :
#     #   #       dat_group %>% dplyr::group_by_at(dplyr::vars(tidyselect::all_of(.x)), .add = TRUE, .drop = FALSE) %>%
#     #   #         dplyr::summarise(n =dplyr::n(), weighted_n = sum(!!wt), .groups = "drop") %>%
#     #   #         dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("factor"),
#     #   #                       res = NA_real_) %>%
#     #   #         dplyr::rename_at(dplyr::vars(tidyselect::all_of(.x)), ~ ".SUP"),
#     #   #       .else = function(.x)  # Numeric vars :
#     #   #         dat_group %>%
#     #   #         dplyr::summarise(n =dplyr::n(), weighted_n = sum(!!wt),
#     #   #                          res = stats::weighted.mean(!!rlang::sym(.x), !!wt, na.rm = TRUE),
#     #   #                          moe_res = suppressWarnings(MeanCI(!!rlang::sym(.x), conf.level = conf_level, na.rm = TRUE)) %>%
#     #   #                            t() %>% tibble::as_tibble() %>% dplyr::mutate(ci = upr.ci - mean) %>% dplyr::pull(ci) %>% round(7),
#     #   #                          .groups = "drop") %>%
#     #   #         dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("num"), .SUP = factor(.x)) )
#     #   # } else { # if (confidence_intervals == FALSE)
#     #     sup_tab_calculation <- sup_names %>%
#     #       purrr::map_if(sup_text, function(.x) # Character and factor vars :
#     #         dat_group %>% dplyr::group_by_at(dplyr::vars(tidyselect::all_of(.x)), .add = TRUE, .drop = FALSE) %>%
#     #           dplyr::summarise(n =dplyr::n(), weighted_n = sum(!!wt), .groups = "drop") %>%
#     #           dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("factor"),
#     #                         res = NA_real_) %>%
#     #           dplyr::rename_at(dplyr::vars(tidyselect::all_of(.x)), ~ ".SUP"),
#     #         .else = function(.x)  # Numeric vars :
#     #           dat_group %>%
#     #           dplyr::summarise(n =dplyr::n(), weighted_n = sum(!!wt),
#     #                            res = stats::weighted.mean(!!rlang::sym(.x), !!wt, na.rm = TRUE), .groups = "drop") %>%
#     #           dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("num"), .SUP = factor(.x)) )
#     # #  }
#     #
#     # } else { #    if (accelerate == TRUE)
#     # if (confidence_intervals == TRUE) {
#     #   sup_tab_calculation <- sup_names %>%
#     #     purrr::map_if(sup_text, function(.x) # Character and factor vars :
#     #       dat_group %>% dplyr::group_by_at(dplyr::vars(tidyselect::all_of(.x)), .add = TRUE, .drop = FALSE) %>%
#     #         dplyr::summarise(weighted_n = sum(!!wt), .groups = "drop") %>%
#     #         dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("factor"),
#     #                       res = NA_real_) %>%
#     #         dplyr::rename_at(dplyr::vars(tidyselect::all_of(.x)), ~ ".SUP"),
#     #       .else = function(.x)  # Numeric vars :
#     #         dat_group %>%
#     #         dplyr::summarise(weighted_n = sum(!!wt),
#     #                          res = stats::weighted.mean(!!rlang::sym(.x), !!wt, na.rm = TRUE),
#     #                          moe_res = suppressWarnings(MeanCI(!!rlang::sym(.x), conf.level = conf_level, na.rm = TRUE)) %>%
#     #                            t() %>% tibble::as_tibble() %>% dplyr::mutate(ci = upr.ci - mean) %>% dplyr::pull(ci) %>% round(7),
#     #                          .groups = "drop") %>%
#     #         dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("num"), .SUP = factor(.x)) )
#     # } else { # if (confidence_intervals == FALSE)
#     sup_tab_calculation <- sup_names %>%
#       purrr::map_if(sup_text, function(.x) # Character and factor vars :
#         dat_group %>% dplyr::group_by_at(dplyr::vars(tidyselect::all_of(.x)), .add = TRUE, .drop = FALSE) %>%
#           dplyr::summarise(n = dplyr::n(), weighted_n = sum(!!wt), .groups = "drop") %>%
#           dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("factor"),
#                         res = NA_real_) %>%
#           dplyr::rename_at(dplyr::vars(tidyselect::all_of(.x)), ~ ".SUP"),
#         .else = function(.x)  # Numeric vars :
#           dat_group %>%
#           dplyr::summarise(n = dplyr::n(),
#                            weighted_n = sum(!!wt),
#                            res = stats::weighted.mean(!!rlang::sym(.x), !!wt, na.rm = TRUE),
#                            .groups = "drop") %>%
#           dplyr::mutate(.SUP_NAME = factor(.x), .TYPE = factor("num"), .SUP = factor(.x)) )
#     #  }
#     # }
#
#     sup_tab_calculation %<>% purrr::map_if(purrr::map_lgl(., ~ ! rlang::quo_name(var1) %in% colnames(.)),
#                                            ~ dplyr::mutate(., !!var1 := factor("Total")))
#     sup_tab_calculation %<>% purrr::map_if(purrr::map_lgl(., ~ ! rlang::quo_name(var2) %in% colnames(.)),
#                                            ~ dplyr::mutate(., !!var2 := factor("Total")))
#     sup_tab_calculation %<>% purrr::map_if(purrr::map_lgl(., ~ ! rlang::quo_name(var3) %in% colnames(.)),
#                                            ~ dplyr::mutate(., !!var3 := factor("Total")))
#
#     duplicated_levels <- sup_tab_calculation %>%
#       purrr::map(~ dplyr::pull(., .SUP) %>% levels()) %>% purrr::flatten_chr() %>% .[duplicated(.)] %>% unique()
#     new_levels <- sup_tab_calculation %>%
#       purrr::map(~ dplyr::filter(., .SUP %in% duplicated_levels) %>%
#                    dplyr::group_by(.SUP) %>% dplyr::slice(1) %>%
#                    dplyr::mutate(.SUP2 = stringr::str_c(.SUP, "_", .SUP_NAME)) %>%
#                    dplyr::mutate(.SUP = magrittr::set_names(as.character(.SUP), .SUP2) ) %>% dplyr::pull(.SUP) )
#     where_new_levels <- new_levels %>% purrr::map_lgl(~ length(.) != 0)
#     sup_tab_calculation[where_new_levels] <- sup_tab_calculation[where_new_levels] %>%
#       purrr::map2(new_levels[where_new_levels], ~ dplyr::mutate(.x, .SUP = fct_rename(.SUP, c(.y))))
#
#     sup_tab_calculation %>%
#       purrr::map(~ dplyr::mutate(., .zone = factor(.zone)) %>%
#                    dplyr::select(.zone, !!var3, !!var1, !!var2, .SUP_NAME, .TYPE, .SUP,
#                                  tidyselect::everything(), tidyselect::any_of("n"), weighted_n) %>%
#                    dplyr::arrange(!!var3)  ) %>%
#       dplyr::bind_rows()
#   }
#
#   if (length(sup_cols) != 0) {
#     dat_group31 <- dat_group3 %>%
#       dplyr::group_by(!!var1, .add = TRUE, .drop = FALSE)
#
#     # if (confidence_intervals == TRUE & design_effect == TRUE) var3_deff <- wtable %>% dplyr::group_by(!!var3) %>%
#     #   dplyr::summarise(deff = dplyr::first(deff), .groups = "keep") %>% dplyr::mutate(.zone = factor("deff"))
#
#     if(any(sup_cols_text)) {
#       # if (accelerate == FALSE) {
#       #   sup_cols_tabs_text <- dat_group31 %>%
#       #     sup_tab_calc(sup_cols[sup_cols_text], sup_cols_text[sup_cols_text], .zone = "sup_cols", confidence_intervals = confidence_intervals)
#       #   if (no_var3 == FALSE ) sup_cols_tabs_text %<>%
#       #     dplyr::group_by(.SUP_NAME, !!var1, .SUP) %>%
#       #     dplyr::bind_rows(dplyr::summarise(., !!var3 := factor("Total"), !!var2 := factor("Total"),
#       #                                       .TYPE = dplyr::first(.TYPE), .zone = factor("sup_cols"),
#       #                                       n = sum(n), weighted_n = sum(weighted_n), .groups = "drop"))
#       #
#       # } else { #If (accelerate == TRUE)
#       sup_cols_tabs_text <- dat_group31 %>%
#         sup_tab_calc(sup_cols[sup_cols_text], sup_cols_text[sup_cols_text], .zone = "sup_cols") # accelerate = TRUE, confidence_intervals = confidence_intervals
#       if (no_var3 == FALSE) sup_cols_tabs_text %<>%
#         dplyr::group_by(.SUP_NAME, !!var1, .SUP) %>%
#         dplyr::bind_rows(dplyr::summarise(., !!var3 := factor("Total"), !!var2 := factor("Total"),
#                                           .TYPE = dplyr::first(.TYPE), .zone = factor("sup_cols"),
#                                           n = sum(n), weighted_n = sum(weighted_n), .groups = "drop"))
#       # }
#
#       sup_cols_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3, !!var1) %>% dplyr::mutate(.tot1 = sum(n), .wtot1 = sum(weighted_n))
#
#       sup_cols_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3) %>% dplyr::mutate(.wtot3 = sum(weighted_n))
#
#       #if (accelerate == FALSE) sup_cols_tabs_text %<>% dplyr::mutate(.tot3 = sum(n)) #TRUE ?
#
#       # if (accelerate == FALSE) {
#       #   sup_cols_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3, .SUP) %>%
#       #     dplyr::bind_rows(dplyr::summarise(., !!var1 := factor("Total"), !!var2 := factor("Total"),
#       #                                       n = sum(n), weighted_n = sum(weighted_n), .TYPE = dplyr::first(.TYPE),
#       #                                       .tot1 = dplyr::first(.tot3), .wtot1 = dplyr::first(.wtot3), .zone = factor("sup_cols"),
#       #                                       .tot3 = dplyr::first(.tot3), .wtot3 = dplyr::first(.wtot3), .groups = "drop") )
#       #
#       # } else { # if (accelerate == TRUE)
#         sup_cols_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3, .SUP) %>%
#           dplyr::bind_rows(dplyr::summarise(., !!var1 := factor("Total"), !!var2 := factor("Total"),
#                                             n = sum(n), weighted_n = sum(weighted_n), .TYPE = dplyr::first(.TYPE),
#                                             .tot1 = sum(.tot1),
#                                             .wtot1 = dplyr::first(.wtot3), .zone = factor("sup_cols"),
#                                             .wtot3 = dplyr::first(.wtot3), .groups = "drop") )
#      # }
#
#       #Percentages and confidence intervals:
#       sup_cols_tabs_text %<>% dplyr::mutate(pct = weighted_n/.wtot1)
#
#       # if (confidence_intervals == TRUE) {
#       #   sup_cols_tabs_text %<>%
#       #     dplyr::mutate(moe = DescTools::BinomCI(pct*.tot1, .tot1, method = "wilson",
#       #                                            conf.level = conf_level) %>% as.data.frame() %>%
#       #                     dplyr::mutate(ci = (upr.ci - est)) %>% dplyr::pull(ci) %>% tidyr::replace_na(0) %>% round(7))
#       #
#       #   if (design_effect == TRUE) sup_cols_tabs_text %<>% dplyr::group_by(!!var3) %>% dplyr::bind_rows(var3_deff) %>%
#       #     dplyr::mutate(deff = dplyr::last(deff)) %>% dplyr::filter(!.zone == "deff") %>% dplyr::ungroup() %>%
#       #     dplyr::mutate(ci = ci * deff)
#       #
#       #   sup_cols_tabs_text %<>%
#       #     dplyr::mutate(conf_level = conf_level,
#       #                   res_min = round(pmax((pct - moe)*100, 0), digits),  #stringr::str_replace_all(., "(100)\\.0+%", "\\1%")
#       #                   res_max = round(pmin((pct + moe)*100, 100), digits), #stringr::str_replace_all(., "(100)\\.0+%", "\\1%")
#       #                   resCI = dplyr::if_else(res_min == res_max, stringr::str_c(res_min, "%"), stringr::str_c(res_min, "-", res_max, "%") )) %>% #stringr::str_remove(., "%(?=-)") %>% stringr::str_replace_all("\\.", ",")
#       #     dplyr::select(-res_min, - res_max)  #stringr::str_pad(res_min, max(stringr::str_length(res_min[res_min != res_max])))
#       # }
#     }
#
#
#     #Numeric variables :
#     if(any(sup_cols_num)) {
#       if (no_var3 == FALSE) {
#         sup_cols_tabs_num <-
#           dplyr::bind_rows(
#             dat_group31 %>%
#               sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols"), #confidence_intervals = confidence_intervals
#             dat %>% dplyr::group_by(!!var1, .drop = FALSE) %>%
#               sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols"), #confidence_intervals = confidence_intervals
#             dat_group3 %>%
#               sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols"), #confidence_intervals = confidence_intervals
#             dat %>%
#               sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols")  ) #confidence_intervals = confidence_intervals
#       } else {
#         sup_cols_tabs_num <-
#           dplyr::bind_rows(
#             dat_group31 %>% sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols"), #, confidence_intervals = confidence_intervals
#             dat_group3 %>%  sup_tab_calc(sup_cols[sup_cols_num], sup_cols_text[sup_cols_num], .zone = "sup_cols")) #, confidence_intervals = confidence_intervals
#       }
#
#
#       # if (keep_unused_levels == FALSE) sup_cols_tabs_num %<>%
#       #   dplyr::group_by(.SUP_NAME, !!var3, !!var1) %>%
#       #   dplyr::filter(!all(weighted_n == 0))
#
#       # if (confidence_intervals == TRUE) {
#       #   if (design_effect == TRUE) sup_cols_tabs_num %<>% dplyr::group_by(!!var3) %>% dplyr::bind_rows(var3_deff) %>%
#       #     dplyr::mutate(deff = dplyr::last(deff)) %>% dplyr::filter(!.zone == "deff") %>% dplyr::ungroup() %>%
#       #     dplyr::mutate(moe_res = round(moe_res * deff, 7))
#       #   sup_cols_tabs_num %<>%
#       #     dplyr::mutate(res_min = round(pmax(res - moe_res, 0)),   #, digits
#       #                   res_max = round(res + moe_res),            #, digits
#       #                   resCI = dplyr::if_else(res_min == res_max, stringr::str_c(res_min), stringr::str_c(res_min, "-", res_max) )) %>%
#       #     dplyr::select(-res_min, - res_max)
#       # }
#     }
#
#     #Put together text and numeric variables
#     if (any(sup_cols_text) & any(sup_cols_num)){
#       sup_cols_tabs <-
#         dplyr::bind_rows(sup_cols_tabs_text, sup_cols_tabs_num)
#     } else if (any(sup_cols_text)) {
#       sup_cols_tabs <- sup_cols_tabs_text
#     } else if (any(sup_cols_num)) {
#       sup_cols_tabs <- sup_cols_tabs_num
#     }
#
#
#     sup_cols_tabs %<>% dplyr::ungroup() %>%
#       dplyr::mutate(!!var2 := factor("sup_cols")) %>%
#       dplyr::arrange(.TYPE, .SUP_NAME, !!var3, !!var1, !!var2)
#
#     if (only_first_level == TRUE) {
#       sup_cols_tabs %<>% dplyr::group_by(!!var3, .SUP_NAME, !!var1) %>%
#         dplyr::slice(1) %>% dplyr::ungroup()
#     } else if (not_last_level == TRUE) {
#       sup_cols_tabs %<>% dplyr::group_by(!!var3, .SUP_NAME, !!var1) %>%
#         dplyr::filter(.SUP != dplyr::last(.SUP)) %>%
#         dplyr::ungroup()
#     }
#
#     #Add a total column
#     if ("col" %in% tot & any(sup_cols_text)) {
#       sup_cols_tabs <- sup_cols_tabs %>%
#         dplyr::group_by(!!var1, !!var3) %>%
#         dplyr::bind_rows(dplyr::summarise(., .SUP_NAME = "Ensemble", .SUP = "Ensemble",
#                                           .zone = "sup_cols",
#                                           .TYPE = "factor", !!var2 := "sup_cols",
#                                           n = dplyr::first(.tot1),
#                                           weighted_n = dplyr::first(.wtot1),
#                                           pct = as_pct(vctrs::vec_data(dplyr::first(.wtot1))/
#                                                          vctrs::vec_data(dplyr::first(.wtot3))),
#                                           .tot1 = dplyr::first(.tot1),
#                                           .wtot1 = dplyr::first(.wtot1),
#                                           .wtot3 = dplyr::first(.wtot3),
#                                           .groups = "drop")) #%>%
#         #dplyr::ungroup()
#     }
#   }
#
#
#
#   #Supplementary rows :
#   if (length(sup_rows) != 0) { #& multicols == FALSE
#     dat_group32 <- dat_group3 %>%
#       dplyr::group_by(!!var2, .add = TRUE, .drop = FALSE)
#
#     # if (confidence_intervals == TRUE & design_effect == TRUE) var3_deff <-  wtable %>% dplyr::group_by(!!var3) %>%
#     #   dplyr::summarise(deff = dplyr::first(deff), .groups = "keep") %>% dplyr::mutate(.zone = factor("deff"))
#
#     if(any(sup_rows_text))  {
#       sup_rows_tabs_text <- dat_group32 %>%
#         sup_tab_calc(sup_rows[sup_rows_text], sup_rows_text[sup_rows_text], .zone = "sup_rows") #confidence_intervals = confidence_intervals
#       if (no_var3 == FALSE) {
#         sup_rows_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var2, .SUP)
#         # if (accelerate == FALSE) {
#         #   sup_rows_tabs_text %<>%
#         #     dplyr::bind_rows(dplyr::summarise(., !!var3 := factor("Total"), !!var1 := factor("Total"),
#         #                                       .TYPE = dplyr::first(.TYPE), .zone = factor("sup_rows"),
#         #                                       n = sum(n), weighted_n = sum(weighted_n), .groups = "drop"))
#         # } else { #if (accelerate == TRUE)
#         sup_rows_tabs_text %<>%
#           dplyr::bind_rows(dplyr::summarise(., !!var3 := factor("Total"), !!var1 := factor("Total"),
#                                             .TYPE = dplyr::first(.TYPE), .zone = factor("sup_rows"),
#                                             weighted_n = sum(weighted_n),  .groups = "drop"))
#         #}
#       }
#
#       sup_rows_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3, !!var2) %>%
#         dplyr::mutate(.tot2 = sum(n), .wtot2 = sum(weighted_n))
#
#       sup_rows_tabs_text %<>% dplyr::group_by(.SUP_NAME, !!var3) %>%
#         dplyr::mutate(.wtot3 = sum(weighted_n))
#       #if (accelerate == FALSE) sup_rows_tabs_text %<>%
#       #   dplyr::mutate(.tot3 = sum(n)) #TRUE ?
#
#       # if (accelerate == FALSE) {
#       #   sup_rows_tabs_text %<>%
#       #     dplyr::group_by(.SUP, .add = TRUE) %>%
#       #     dplyr::bind_rows(
#       #       dplyr::summarise(
#       #         .,
#       #         !!var2 := factor("Total"),
#       #         !!var1 := factor("Total"),
#       #         n = sum(n),
#       #         weighted_n = sum(weighted_n),
#       #         .TYPE = dplyr::first(.TYPE),
#       #         .tot2 = dplyr::first(.tot3),
#       #         .wtot2 = dplyr::first(.wtot3),
#       #         .zone = factor("sup_rows"),
#       #         .tot3 = dplyr::first(.tot3),
#       #         .wtot3 = dplyr::first(.wtot3),
#       #         .groups = "drop"
#       #       )
#       #     )
#       # } else {
#       #if (accelerate == TRUE)
#       sup_rows_tabs_text %<>%
#         dplyr::group_by(.SUP, .add = TRUE) %>%
#         dplyr::bind_rows(
#           dplyr::summarise(
#             .,
#             !!var2 := factor("Total"),
#             !!var1 := factor("Total"),
#             # n = sum(n),
#             weighted_n = sum(weighted_n),
#             .TYPE = dplyr::first(.TYPE),
#             .tot2 = sum(.tot2),
#             .wtot2 = dplyr::first(.wtot3),
#             .zone = factor("sup_rows"),
#             .wtot3 = dplyr::first(.wtot3),
#             .groups = "drop"
#           )
#         )
#       #}
#
#       #Percentages
#       sup_rows_tabs_text %<>% dplyr::mutate(pct = weighted_n/.wtot2)
#
#       #   #Confidence intervals:
#       #   if (confidence_intervals == TRUE) {
#       #     sup_rows_tabs_text %<>%
#       #       dplyr::mutate(moe = DescTools::BinomCI(pct*.tot2, .tot2, method = "wilson",
#       #                                              conf.level = conf_level) %>%  as.data.frame() %>%
#       #                       dplyr::mutate(ci = upr.ci - est) %>% dplyr::pull(ci) %>% tidyr::replace_na(0) %>% round(7))
#       #     if (design_effect == TRUE) sup_rows_tabs_text %<>% dplyr::group_by(!!var3) %>% dplyr::bind_rows(var3_deff) %>%
#       #       dplyr::mutate(deff = dplyr::last(deff)) %>% dplyr::filter(!.zone == "deff") %>% dplyr::ungroup() %>%
#       #       dplyr::mutate(ci = ci * deff)
#       #
#       #     sup_rows_tabs_text %<>%
#       #       dplyr::mutate(conf_level = conf_level,
#       #                     res_min = round(pmax((pct - moe)*100, 0), digits),  #stringr::str_replace_all(., "(100)\\.0+%", "\\1%")
#       #                     res_max = round(pmin((pct + moe)*100, 100), digits), #stringr::str_replace_all(., "(100)\\.0+%", "\\1%")
#       #                     resCI = dplyr::if_else(res_min == res_max, stringr::str_c(res_min, "%"), stringr::str_c(res_min, "-", res_max, "%") )) %>% #stringr::str_remove(., "%(?=-)") %>% stringr::str_replace_all("\\.", ",")
#       #       dplyr::select(-res_min, - res_max)  #stringr::str_pad(res_min, max(stringr::str_length(res_min[res_min != res_max])))
#       #   }
#     }
#
#
#     #Numeric variables :
#     if(any(sup_rows_num)) {
#       if (no_var3 == FALSE) {
#         sup_rows_tabs_num <-
#           dplyr::bind_rows(
#             dat_group32 %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals),
#             dat %>% dplyr::group_by(!!var2, .drop = FALSE) %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals),
#             dat_group3 %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals),
#             dat %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals)  )
#       } else {
#         sup_rows_tabs_num <-
#           dplyr::bind_rows(
#             dat_group32 %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals),
#             dat_group3 %>%
#               sup_tab_calc(sup_rows[sup_rows_num], sup_rows_text[sup_rows_num], .zone = "sup_rows", confidence_intervals = confidence_intervals))
#       }
#
#
#       #   if (confidence_intervals == TRUE) {
#       #     if (design_effect == TRUE) sup_rows_tabs_num %<>% dplyr::group_by(!!var3) %>% dplyr::bind_rows(var3_deff) %>%
#       #       dplyr::mutate(deff = dplyr::last(deff)) %>% dplyr::filter(!.zone == "deff") %>% dplyr::ungroup() %>%
#       #       dplyr::mutate(moe_res = round(moe_res * deff, 7))
#       #     sup_rows_tabs_num %<>%
#       #       dplyr::mutate(res_min = round(pmax(res - moe_res, 0)),   #, digits
#       #                     res_max = round(res + moe_res),            #, digits
#       #                     resCI = dplyr::if_else(res_min == res_max, stringr::str_c(res_min), stringr::str_c(res_min, "-", res_max) )) %>%
#       #       dplyr::select(-res_min, - res_max)
#       #   }
#     }
#
#
#
#     #Put together text and numeric variables
#     if (any(sup_rows_text) & any(sup_rows_num)){
#       sup_rows_tabs <-
#         dplyr::bind_rows(sup_rows_tabs_text, sup_rows_tabs_num)
#     } else if (any(sup_rows_text)) {
#       sup_rows_tabs <- sup_rows_tabs_text
#     } else if (any(sup_rows_num)) {
#       sup_rows_tabs <- sup_rows_tabs_num
#     }
#     sup_rows_tabs %<>% dplyr::ungroup() %>% dplyr::mutate(!!var1 := factor("sup_rows")) %>%
#       dplyr::arrange(.TYPE, .SUP_NAME, !!var3, !!var2, !!var1)
#
#     if (only_first_level == TRUE) {
#       sup_rows_tabs %<>% dplyr::group_by(!!var3, .SUP_NAME, !!var2) %>% dplyr::slice(1) %>% dplyr::ungroup() %>%
#         dplyr::mutate(.SUP = forcats::fct_drop(.SUP))
#     }  else if (not_last_level == TRUE) {
#       sup_rows_tabs %<>% dplyr::group_by(!!var3, .SUP_NAME, !!var2) %>% dplyr::filter(.SUP != dplyr::last(.SUP)) %>% dplyr::ungroup() %>%
#         dplyr::mutate(.SUP = forcats::fct_drop(.SUP))
#     }
#
#     #Add a total row
#     if ("row" %in% tot & any(sup_rows_text)) {
#       sup_rows_tabs <- sup_rows_tabs %>%
#         dplyr::group_by(!!var2, !!var3) %>%
#         dplyr::bind_rows(dplyr::summarise(., .SUP_NAME = "Ensemble", .SUP = "Ensemble",
#                                           .zone = "sup_rows",
#                                           .TYPE = "factor", !!var1 := "sup_rows",
#                                           n = dplyr::first(.tot2),
#                                           weighted_n = dplyr::first(.wtot2),
#                                           pct = as_pct(vctrs::vec_data(dplyr::first(.wtot2))/
#                                                          vctrs::vec_data(dplyr::first(.wtot3))),
#                                           .tot2 = dplyr::first(.tot2),
#                                           .wtot2 = dplyr::first(.wtot2),
#                                           .wtot3 = dplyr::first(.wtot3),
#                                           .groups = "drop")) #%>%
#         #dplyr::ungroup()
#     }
#
#
#   }
#
#
#
#
#
#   if (length(sup_cols) != 0 & length(sup_rows) != 0) {
#     wtable_sup <- dplyr::bind_rows(sup_cols_tabs, sup_rows_tabs)
#   } else if (length(sup_cols) != 0 ) {
#     wtable_sup  <- sup_cols_tabs
#   } else if (length(sup_rows) != 0) {
#     wtable_sup  <- sup_rows_tabs
#   }
#
#
#
#   # #What to keep here ?
#   # wtable_sup %<>% dplyr::select(
#   #   .zone, !!var3, !!var1, !!var2,
#   #   tidyselect::any_of(c(".SUP_NAME", ".SUP",
#   #                        "pct", "moe", "resCI", "n")),
#   #   weighted_n,
#   #   tidyselect::any_of(c("moe_wn", "res", "moe_res", "contrib", "ctr_mean",
#   #                        "pct1", "pct2", "freq", "freqn",
#   #                        ".tot1", ".wtot1", ".tot2", ".wtot2", ".tot3", ".wtot3",
#   #                        ".totn", ".wtotn", "an_totcol", "an_totrow",
#   #                        "deff", "conf_level")), .TYPE,
#   #   # tidyselect::any_of(c("expected", "spread", "binding_ratio",
#   #   #                      "ctr_abs", "Vnuage", "ctr_no_sign")),
#   #   tidyselect::everything())
#
#   wtable_sup %<>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("pct", "moe", "pct1", "pct2", "freq", "freqn",
#                                                      "contrib", "ctr_mean", "expected", "spread", "binding_ratio", "ctr_no_sign")),
#                                 ~ pct(., digits = digits))) %>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("moe_wn", ".tot1", ".wtot1", ".tot2", ".wtot2",
#                                                      ".tot3", ".wtot3", ".totn", ".wtotn", "n", "weighted_n")),
#                                 ~ decimal(., digits = 0L))) %>%
#     dplyr::mutate(dplyr::across(tidyselect::any_of(c("ctr_abs", "Vnuage")),
#                                 ~ decimal(., digits = digits + 2L)))
#
#   if (no_var3 == FALSE) wtable_sup %<>%
#     dplyr::mutate(!!var3 := suppressWarnings(
#       forcats::fct_recode(!!var3, "Ensemble" = "Total"))
#     )
#
#   new_tab_df(wtable_sup, perc[1], data = tibble::tibble(), wt = as.character(wt))
#
# }
#
#
#
#
# #' @keywords internal
# tab_sort_rows <- function(wtable, sort_by = "no", row_var, col_var, tab_var) {
#
#   if (sort_by[1] == "no") {
#     return(wtable)
#     }
#
#   if (missing(row_var)) {row_var <- rlang::sym(names(wtable)[3])
#   } else {row_var <- rlang::ensym(row_var)}
#   if (missing(col_var)) {col_var <- rlang::sym(names(wtable)[4])
#   } else {col_var <- rlang::ensym(col_var)}
#   if (missing(tab_var)) {tab_var <- rlang::sym(names(wtable)[2])
#   } else {tab_var <- rlang::ensym(tab_var)}
#
#   perc <- wtable %>% purrr::pluck(purrr::attr_getter("perc"))
#
#   #Sort row variable by another variable (change the order of factor levels ;
#   # can't be done before data is split by var3 => must be done while drawing the tabs)
#     desc_order <- if (is.na(sort_by[2] == "desc")) {FALSE} else {sort_by[2] == "desc"}
#     if (sort_by[1] %in% (dplyr::pull(wtable, !!col_var) %>% levels()) ) {
#      sort_var <- if (perc == "no") {rlang::sym("weighted_n")} else {rlang::sym("pct")} #Result ?
#        col_var_sort <-  wtable %>%
#         dplyr::filter(.zone == "base" & !!col_var == sort_by[1]) %>%
#         dplyr::group_by(!!tab_var) %>%
#         dplyr::group_split() %>%
#         purrr::map(~ #dplyr::mutate(., pct1 = vctrs::vec_data(.wtot1)/
#                      #                vctrs::vec_data(.wtot3)) %>%
#                      dplyr::mutate_at(., dplyr::vars(!!row_var),
#                                       ~ forcats::fct_reorder(., !!sort_var,
#                                                              .fun = sum,
#                                                              .desc = desc_order) %>%
#                                         forcats::fct_relevel("Total",
#                                                              after = Inf) ) %>%
#                      dplyr::pull(!!row_var) %>% levels() )  #.desc = TRUE #  #dplyr::arrange(!!row_var)
#
#     } else if (sort_by[1] %in% (dplyr::pull(dplyr::filter(wtable,
#                                                           .zone == "sup_cols"),
#                                             .SUP) %>% levels()) ) {
#
#       wtable_sup_sort <- wtable %>%
#         dplyr::filter(.zone == "sup_cols" & .SUP == sort_by[1])
#
#       sort_text_num <- wtable_sup_sort %>%
#         dplyr::pull(.TYPE) %>% forcats::fct_drop() %>% levels()
#
#       if (sort_text_num == "num") {
#         col_var_sort <- wtable_sup_sort %>%
#           dplyr::group_by(!!tab_var) %>%
#           dplyr::group_split() %>%
#           purrr::map(~ dplyr::mutate_at(., dplyr::vars(!!row_var),
#                                         ~ forcats::fct_reorder(., res, .fun = sum,
#                                                                .desc = desc_order) %>%
#                                           forcats::fct_relevel("Total",
#                                                                after = Inf) ) %>%
#                        dplyr::pull(!!row_var) %>% levels())  #.desc = TRUE #
#       } else if (sort_text_num == "factor") {
#         col_var_sort <- wtable_sup_sort %>% dplyr::group_by(!!tab_var) %>%
#           dplyr::group_split() %>%
#           purrr::map(~ dplyr::mutate_at(., dplyr::vars(!!row_var),
#                                         ~forcats::fct_reorder(., pct, .fun = sum,
#                                                               .desc = desc_order) %>%
#                                           forcats::fct_relevel("Total",
#                                                                after = Inf) ) %>%
#                        dplyr::pull(!!row_var) %>% levels())  #.desc = TRUE #
#       }
#     } else {
#       warning(stringr::str_c(
#         "Sorting column ", sort_by[1],
#         " was found neither in levels of the second variable nor in supplementary columns"
#       )) # or another total ?
#       col_var_sort <- list(levels(dplyr::pull(wtable, !!row_var)))
#     }
#
#     wtable %>% `attr<-`("col_var_sort", col_var_sort)
# }
#
#
# # wtable = wtables[[1]]
# # result_text = rlang::sym(result_sup_text_var[[1]])
# # result_num = rlang::sym(result_sup_num_var[[1]])
# # row_var = rlang::sym(".SUP")
# # col_var = rlang::sym(names(wtable)[4])
# # tab_var = rlang::sym(names(wtable)[2])
# # zone = "sup_rows"
# # tot = totals[[1]]  #subtext ?
# # totaltab = "table"
# # keep_unused_levels = keep_unused_levels[[1]]
# # perc = "row"
# # col_var_sort = "no"
# # subtext = ""
# # reverse_row_col = FALSE
#
#
#
#
#
#
#
#
#
